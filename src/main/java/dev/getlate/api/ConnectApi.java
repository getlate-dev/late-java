/*
 * Late API
 * API reference for Late. Authenticate with a Bearer API key. Base URL: https://getlate.dev/api 
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: support@getlate.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.getlate.api;

import dev.getlate.ApiClient;
import dev.getlate.ApiException;
import dev.getlate.ApiResponse;
import dev.getlate.Configuration;
import dev.getlate.Pair;

import dev.getlate.model.CompleteTelegramConnect200Response;
import dev.getlate.model.ConnectBlueskyCredentials200Response;
import dev.getlate.model.ConnectBlueskyCredentialsRequest;
import dev.getlate.model.ErrorResponse;
import dev.getlate.model.GetConnectUrl200Response;
import dev.getlate.model.GetFacebookPages200Response;
import dev.getlate.model.GetGmbLocations200Response;
import dev.getlate.model.GetLinkedInOrganizations200Response;
import dev.getlate.model.GetPendingOAuthData200Response;
import dev.getlate.model.GetPinterestBoards200Response;
import dev.getlate.model.GetRedditFlairs200Response;
import dev.getlate.model.GetRedditSubreddits200Response;
import dev.getlate.model.GetTelegramConnectStatus200Response;
import dev.getlate.model.GetYouTubeDailyViews400Response;
import dev.getlate.model.HandleOAuthCallbackRequest;
import dev.getlate.model.InitiateTelegramConnect200Response;
import dev.getlate.model.InitiateTelegramConnectRequest;
import dev.getlate.model.InlineObject;
import dev.getlate.model.ListFacebookPages200Response;
import dev.getlate.model.ListGoogleBusinessLocations200Response;
import dev.getlate.model.ListLinkedInOrganizations200Response;
import dev.getlate.model.ListPinterestBoardsForSelection200Response;
import dev.getlate.model.ListSnapchatProfiles200Response;
import dev.getlate.model.SelectFacebookPage200Response;
import dev.getlate.model.SelectFacebookPageRequest;
import dev.getlate.model.SelectGoogleBusinessLocation200Response;
import dev.getlate.model.SelectGoogleBusinessLocationRequest;
import dev.getlate.model.SelectLinkedInOrganization200Response;
import dev.getlate.model.SelectLinkedInOrganizationRequest;
import dev.getlate.model.SelectPinterestBoard200Response;
import dev.getlate.model.SelectPinterestBoardRequest;
import dev.getlate.model.SelectSnapchatProfile200Response;
import dev.getlate.model.SelectSnapchatProfileRequest;
import java.net.URI;
import dev.getlate.model.UpdateFacebookPage200Response;
import dev.getlate.model.UpdateFacebookPageRequest;
import dev.getlate.model.UpdateGmbLocation200Response;
import dev.getlate.model.UpdateGmbLocationRequest;
import dev.getlate.model.UpdateLinkedInOrganizationRequest;
import dev.getlate.model.UpdatePinterestBoardsRequest;
import dev.getlate.model.UpdateRedditSubreddits200Response;
import dev.getlate.model.UpdateRedditSubredditsRequest;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2026-02-17T13:13:20.839364865Z[Etc/UTC]", comments = "Generator version: 7.19.0")
public class ConnectApi {
  /**
   * Utility class for extending HttpRequest.Builder functionality.
   */
  private static class HttpRequestBuilderExtensions {
    /**
     * Adds additional headers to the provided HttpRequest.Builder. Useful for adding method/endpoint specific headers.
     *
     * @param builder the HttpRequest.Builder to which headers will be added
     * @param headers a map of header names and values to add; may be null
     * @return the same HttpRequest.Builder instance with the additional headers set
     */
    static HttpRequest.Builder withAdditionalHeaders(HttpRequest.Builder builder, Map<String, String> headers) {
        if (headers != null) {
            for (Map.Entry<String, String> entry : headers.entrySet()) {
                builder.header(entry.getKey(), entry.getValue());
            }
        }
        return builder;
    }
  }
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<InputStream>> memberVarAsyncResponseInterceptor;

  public ConnectApi() {
    this(Configuration.getDefaultApiClient());
  }

  public ConnectApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }


  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    InputStream responseBody = ApiClient.getResponseBody(response);
    String body = null;
    try {
      body = responseBody == null ? null : new String(responseBody.readAllBytes());
    } finally {
      if (responseBody != null) {
        responseBody.close();
      }
    }
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Download file from the given response.
   *
   * @param response Response
   * @return File
   * @throws ApiException If fail to read file content from response and write to disk
   */
  public File downloadFileFromResponse(HttpResponse<InputStream> response, InputStream responseBody) throws ApiException {
    if (responseBody == null) {
      throw new ApiException(new IOException("Response body is empty"));
    }
    try {
      File file = prepareDownloadFile(response);
      java.nio.file.Files.copy(responseBody, file.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
      return file;
    } catch (IOException e) {
      throw new ApiException(e);
    }
  }

  /**
   * <p>Prepare the file for download from the response.</p>
   *
   * @param response a {@link java.net.http.HttpResponse} object.
   * @return a {@link java.io.File} object.
   * @throws java.io.IOException if any.
   */
  private File prepareDownloadFile(HttpResponse<InputStream> response) throws IOException {
    String filename = null;
    java.util.Optional<String> contentDisposition = response.headers().firstValue("Content-Disposition");
    if (contentDisposition.isPresent() && !"".equals(contentDisposition.get())) {
      // Get filename from the Content-Disposition header.
      java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("filename=['\"]?([^'\"\\s]+)['\"]?");
      java.util.regex.Matcher matcher = pattern.matcher(contentDisposition.get());
      if (matcher.find())
        filename = matcher.group(1);
    }
    File file = null;
    if (filename != null) {
      java.nio.file.Path tempDir = java.nio.file.Files.createTempDirectory("swagger-gen-native");
      java.nio.file.Path filePath = java.nio.file.Files.createFile(tempDir.resolve(filename));
      file = filePath.toFile();
      tempDir.toFile().deleteOnExit();   // best effort cleanup
      file.deleteOnExit(); // best effort cleanup
    } else {
      file = java.nio.file.Files.createTempFile("download-", "").toFile();
      file.deleteOnExit(); // best effort cleanup
    }
    return file;
  }

  /**
   * Check Telegram status
   * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
   * @param code The access code to check status for (required)
   * @return CompleteTelegramConnect200Response
   * @throws ApiException if fails to make API call
   */
  public CompleteTelegramConnect200Response completeTelegramConnect(@javax.annotation.Nonnull String code) throws ApiException {
    return completeTelegramConnect(code, null);
  }

  /**
   * Check Telegram status
   * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
   * @param code The access code to check status for (required)
   * @param headers Optional headers to include in the request
   * @return CompleteTelegramConnect200Response
   * @throws ApiException if fails to make API call
   */
  public CompleteTelegramConnect200Response completeTelegramConnect(@javax.annotation.Nonnull String code, Map<String, String> headers) throws ApiException {
    ApiResponse<CompleteTelegramConnect200Response> localVarResponse = completeTelegramConnectWithHttpInfo(code, headers);
    return localVarResponse.getData();
  }

  /**
   * Check Telegram status
   * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
   * @param code The access code to check status for (required)
   * @return ApiResponse&lt;CompleteTelegramConnect200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CompleteTelegramConnect200Response> completeTelegramConnectWithHttpInfo(@javax.annotation.Nonnull String code) throws ApiException {
    return completeTelegramConnectWithHttpInfo(code, null);
  }

  /**
   * Check Telegram status
   * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group. Recommended polling interval: 3 seconds. Status values: pending (waiting for user), connected (channel/group linked), expired (generate a new code). 
   * @param code The access code to check status for (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;CompleteTelegramConnect200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CompleteTelegramConnect200Response> completeTelegramConnectWithHttpInfo(@javax.annotation.Nonnull String code, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = completeTelegramConnectRequestBuilder(code, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("completeTelegramConnect", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<CompleteTelegramConnect200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        CompleteTelegramConnect200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<CompleteTelegramConnect200Response>() {});
        

        return new ApiResponse<CompleteTelegramConnect200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder completeTelegramConnectRequestBuilder(@javax.annotation.Nonnull String code, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'code' is set
    if (code == null) {
      throw new ApiException(400, "Missing the required parameter 'code' when calling completeTelegramConnect");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/telegram";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "code";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("code", code));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("PATCH", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Connect Bluesky account
   * Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
   * @param connectBlueskyCredentialsRequest  (required)
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response connectBlueskyCredentials(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest) throws ApiException {
    return connectBlueskyCredentials(connectBlueskyCredentialsRequest, null);
  }

  /**
   * Connect Bluesky account
   * Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
   * @param connectBlueskyCredentialsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response connectBlueskyCredentials(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = connectBlueskyCredentialsWithHttpInfo(connectBlueskyCredentialsRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Connect Bluesky account
   * Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
   * @param connectBlueskyCredentialsRequest  (required)
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> connectBlueskyCredentialsWithHttpInfo(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest) throws ApiException {
    return connectBlueskyCredentialsWithHttpInfo(connectBlueskyCredentialsRequest, null);
  }

  /**
   * Connect Bluesky account
   * Connect a Bluesky account using identifier (handle or email) and an app password. To get your userId for the state parameter, call GET /v1/users which includes a currentUserId field. 
   * @param connectBlueskyCredentialsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> connectBlueskyCredentialsWithHttpInfo(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = connectBlueskyCredentialsRequestBuilder(connectBlueskyCredentialsRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("connectBlueskyCredentials", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ConnectBlueskyCredentials200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ConnectBlueskyCredentials200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ConnectBlueskyCredentials200Response>() {});
        

        return new ApiResponse<ConnectBlueskyCredentials200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder connectBlueskyCredentialsRequestBuilder(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'connectBlueskyCredentialsRequest' is set
    if (connectBlueskyCredentialsRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'connectBlueskyCredentialsRequest' when calling connectBlueskyCredentials");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/bluesky/credentials";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(connectBlueskyCredentialsRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get OAuth connect URL
   * Initiate an OAuth connection flow. Returns an authUrl to redirect the user to. Standard flow: Late hosts the selection UI, then redirects to your redirect_url. Headless mode (headless&#x3D;true): user is redirected to your redirect_url with OAuth data for custom UI. Use the platform-specific selection endpoints to complete. 
   * @param platform Social media platform to connect (required)
   * @param profileId Your Late profile ID (get from /v1/profiles) (required)
   * @param redirectUrl Your custom redirect URL after connection completes. Standard mode appends ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode appends OAuth data params. (optional)
   * @return GetConnectUrl200Response
   * @throws ApiException if fails to make API call
   */
  public GetConnectUrl200Response getConnectUrl(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl) throws ApiException {
    return getConnectUrl(platform, profileId, redirectUrl, null);
  }

  /**
   * Get OAuth connect URL
   * Initiate an OAuth connection flow. Returns an authUrl to redirect the user to. Standard flow: Late hosts the selection UI, then redirects to your redirect_url. Headless mode (headless&#x3D;true): user is redirected to your redirect_url with OAuth data for custom UI. Use the platform-specific selection endpoints to complete. 
   * @param platform Social media platform to connect (required)
   * @param profileId Your Late profile ID (get from /v1/profiles) (required)
   * @param redirectUrl Your custom redirect URL after connection completes. Standard mode appends ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode appends OAuth data params. (optional)
   * @param headers Optional headers to include in the request
   * @return GetConnectUrl200Response
   * @throws ApiException if fails to make API call
   */
  public GetConnectUrl200Response getConnectUrl(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl, Map<String, String> headers) throws ApiException {
    ApiResponse<GetConnectUrl200Response> localVarResponse = getConnectUrlWithHttpInfo(platform, profileId, redirectUrl, headers);
    return localVarResponse.getData();
  }

  /**
   * Get OAuth connect URL
   * Initiate an OAuth connection flow. Returns an authUrl to redirect the user to. Standard flow: Late hosts the selection UI, then redirects to your redirect_url. Headless mode (headless&#x3D;true): user is redirected to your redirect_url with OAuth data for custom UI. Use the platform-specific selection endpoints to complete. 
   * @param platform Social media platform to connect (required)
   * @param profileId Your Late profile ID (get from /v1/profiles) (required)
   * @param redirectUrl Your custom redirect URL after connection completes. Standard mode appends ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode appends OAuth data params. (optional)
   * @return ApiResponse&lt;GetConnectUrl200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetConnectUrl200Response> getConnectUrlWithHttpInfo(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl) throws ApiException {
    return getConnectUrlWithHttpInfo(platform, profileId, redirectUrl, null);
  }

  /**
   * Get OAuth connect URL
   * Initiate an OAuth connection flow. Returns an authUrl to redirect the user to. Standard flow: Late hosts the selection UI, then redirects to your redirect_url. Headless mode (headless&#x3D;true): user is redirected to your redirect_url with OAuth data for custom UI. Use the platform-specific selection endpoints to complete. 
   * @param platform Social media platform to connect (required)
   * @param profileId Your Late profile ID (get from /v1/profiles) (required)
   * @param redirectUrl Your custom redirect URL after connection completes. Standard mode appends ?connected&#x3D;{platform}&amp;profileId&#x3D;X&amp;username&#x3D;Y. Headless mode appends OAuth data params. (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetConnectUrl200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetConnectUrl200Response> getConnectUrlWithHttpInfo(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getConnectUrlRequestBuilder(platform, profileId, redirectUrl, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getConnectUrl", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetConnectUrl200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetConnectUrl200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetConnectUrl200Response>() {});
        

        return new ApiResponse<GetConnectUrl200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getConnectUrlRequestBuilder(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'platform' is set
    if (platform == null) {
      throw new ApiException(400, "Missing the required parameter 'platform' when calling getConnectUrl");
    }
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling getConnectUrl");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/{platform}"
        .replace("{platform}", ApiClient.urlEncode(platform.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "redirect_url";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("redirect_url", redirectUrl));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Facebook pages
   * Returns all Facebook pages the connected account has access to, including the currently selected page.
   * @param accountId  (required)
   * @return GetFacebookPages200Response
   * @throws ApiException if fails to make API call
   */
  public GetFacebookPages200Response getFacebookPages(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getFacebookPages(accountId, null);
  }

  /**
   * List Facebook pages
   * Returns all Facebook pages the connected account has access to, including the currently selected page.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetFacebookPages200Response
   * @throws ApiException if fails to make API call
   */
  public GetFacebookPages200Response getFacebookPages(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetFacebookPages200Response> localVarResponse = getFacebookPagesWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * List Facebook pages
   * Returns all Facebook pages the connected account has access to, including the currently selected page.
   * @param accountId  (required)
   * @return ApiResponse&lt;GetFacebookPages200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetFacebookPages200Response> getFacebookPagesWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getFacebookPagesWithHttpInfo(accountId, null);
  }

  /**
   * List Facebook pages
   * Returns all Facebook pages the connected account has access to, including the currently selected page.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetFacebookPages200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetFacebookPages200Response> getFacebookPagesWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getFacebookPagesRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getFacebookPages", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetFacebookPages200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetFacebookPages200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetFacebookPages200Response>() {});
        

        return new ApiResponse<GetFacebookPages200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getFacebookPagesRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getFacebookPages");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/facebook-page"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List GBP locations
   * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
   * @param accountId  (required)
   * @return GetGmbLocations200Response
   * @throws ApiException if fails to make API call
   */
  public GetGmbLocations200Response getGmbLocations(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getGmbLocations(accountId, null);
  }

  /**
   * List GBP locations
   * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetGmbLocations200Response
   * @throws ApiException if fails to make API call
   */
  public GetGmbLocations200Response getGmbLocations(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetGmbLocations200Response> localVarResponse = getGmbLocationsWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * List GBP locations
   * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
   * @param accountId  (required)
   * @return ApiResponse&lt;GetGmbLocations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetGmbLocations200Response> getGmbLocationsWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getGmbLocationsWithHttpInfo(accountId, null);
  }

  /**
   * List GBP locations
   * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetGmbLocations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetGmbLocations200Response> getGmbLocationsWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getGmbLocationsRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getGmbLocations", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetGmbLocations200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetGmbLocations200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetGmbLocations200Response>() {});
        

        return new ApiResponse<GetGmbLocations200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getGmbLocationsRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getGmbLocations");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/gmb-locations"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List LinkedIn orgs
   * Returns LinkedIn organizations (company pages) the connected account has admin access to.
   * @param accountId  (required)
   * @return GetLinkedInOrganizations200Response
   * @throws ApiException if fails to make API call
   */
  public GetLinkedInOrganizations200Response getLinkedInOrganizations(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getLinkedInOrganizations(accountId, null);
  }

  /**
   * List LinkedIn orgs
   * Returns LinkedIn organizations (company pages) the connected account has admin access to.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetLinkedInOrganizations200Response
   * @throws ApiException if fails to make API call
   */
  public GetLinkedInOrganizations200Response getLinkedInOrganizations(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetLinkedInOrganizations200Response> localVarResponse = getLinkedInOrganizationsWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * List LinkedIn orgs
   * Returns LinkedIn organizations (company pages) the connected account has admin access to.
   * @param accountId  (required)
   * @return ApiResponse&lt;GetLinkedInOrganizations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetLinkedInOrganizations200Response> getLinkedInOrganizationsWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getLinkedInOrganizationsWithHttpInfo(accountId, null);
  }

  /**
   * List LinkedIn orgs
   * Returns LinkedIn organizations (company pages) the connected account has admin access to.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetLinkedInOrganizations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetLinkedInOrganizations200Response> getLinkedInOrganizationsWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getLinkedInOrganizationsRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getLinkedInOrganizations", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetLinkedInOrganizations200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetLinkedInOrganizations200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetLinkedInOrganizations200Response>() {});
        

        return new ApiResponse<GetLinkedInOrganizations200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getLinkedInOrganizationsRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getLinkedInOrganizations");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/linkedin-organizations"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get pending OAuth data
   * Fetch pending OAuth data for headless mode using the pendingDataToken from the redirect URL. One-time use, expires after 10 minutes. No authentication required.
   * @param token The pending data token from the OAuth redirect URL (pendingDataToken parameter) (required)
   * @return GetPendingOAuthData200Response
   * @throws ApiException if fails to make API call
   */
  public GetPendingOAuthData200Response getPendingOAuthData(@javax.annotation.Nonnull String token) throws ApiException {
    return getPendingOAuthData(token, null);
  }

  /**
   * Get pending OAuth data
   * Fetch pending OAuth data for headless mode using the pendingDataToken from the redirect URL. One-time use, expires after 10 minutes. No authentication required.
   * @param token The pending data token from the OAuth redirect URL (pendingDataToken parameter) (required)
   * @param headers Optional headers to include in the request
   * @return GetPendingOAuthData200Response
   * @throws ApiException if fails to make API call
   */
  public GetPendingOAuthData200Response getPendingOAuthData(@javax.annotation.Nonnull String token, Map<String, String> headers) throws ApiException {
    ApiResponse<GetPendingOAuthData200Response> localVarResponse = getPendingOAuthDataWithHttpInfo(token, headers);
    return localVarResponse.getData();
  }

  /**
   * Get pending OAuth data
   * Fetch pending OAuth data for headless mode using the pendingDataToken from the redirect URL. One-time use, expires after 10 minutes. No authentication required.
   * @param token The pending data token from the OAuth redirect URL (pendingDataToken parameter) (required)
   * @return ApiResponse&lt;GetPendingOAuthData200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetPendingOAuthData200Response> getPendingOAuthDataWithHttpInfo(@javax.annotation.Nonnull String token) throws ApiException {
    return getPendingOAuthDataWithHttpInfo(token, null);
  }

  /**
   * Get pending OAuth data
   * Fetch pending OAuth data for headless mode using the pendingDataToken from the redirect URL. One-time use, expires after 10 minutes. No authentication required.
   * @param token The pending data token from the OAuth redirect URL (pendingDataToken parameter) (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetPendingOAuthData200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetPendingOAuthData200Response> getPendingOAuthDataWithHttpInfo(@javax.annotation.Nonnull String token, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getPendingOAuthDataRequestBuilder(token, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getPendingOAuthData", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetPendingOAuthData200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetPendingOAuthData200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetPendingOAuthData200Response>() {});
        

        return new ApiResponse<GetPendingOAuthData200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getPendingOAuthDataRequestBuilder(@javax.annotation.Nonnull String token, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'token' is set
    if (token == null) {
      throw new ApiException(400, "Missing the required parameter 'token' when calling getPendingOAuthData");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/pending-data";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "token";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("token", token));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Pinterest boards
   * Returns the boards available for a connected Pinterest account. Use this to get a board ID when creating a Pinterest post.
   * @param accountId  (required)
   * @return GetPinterestBoards200Response
   * @throws ApiException if fails to make API call
   */
  public GetPinterestBoards200Response getPinterestBoards(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getPinterestBoards(accountId, null);
  }

  /**
   * List Pinterest boards
   * Returns the boards available for a connected Pinterest account. Use this to get a board ID when creating a Pinterest post.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetPinterestBoards200Response
   * @throws ApiException if fails to make API call
   */
  public GetPinterestBoards200Response getPinterestBoards(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetPinterestBoards200Response> localVarResponse = getPinterestBoardsWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * List Pinterest boards
   * Returns the boards available for a connected Pinterest account. Use this to get a board ID when creating a Pinterest post.
   * @param accountId  (required)
   * @return ApiResponse&lt;GetPinterestBoards200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetPinterestBoards200Response> getPinterestBoardsWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getPinterestBoardsWithHttpInfo(accountId, null);
  }

  /**
   * List Pinterest boards
   * Returns the boards available for a connected Pinterest account. Use this to get a board ID when creating a Pinterest post.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetPinterestBoards200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetPinterestBoards200Response> getPinterestBoardsWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getPinterestBoardsRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getPinterestBoards", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetPinterestBoards200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetPinterestBoards200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetPinterestBoards200Response>() {});
        

        return new ApiResponse<GetPinterestBoards200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getPinterestBoardsRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getPinterestBoards");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/pinterest-boards"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List subreddit flairs
   * Returns available post flairs for a subreddit. Some subreddits require a flair when posting.
   * @param accountId  (required)
   * @param subreddit Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for (required)
   * @return GetRedditFlairs200Response
   * @throws ApiException if fails to make API call
   */
  public GetRedditFlairs200Response getRedditFlairs(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull String subreddit) throws ApiException {
    return getRedditFlairs(accountId, subreddit, null);
  }

  /**
   * List subreddit flairs
   * Returns available post flairs for a subreddit. Some subreddits require a flair when posting.
   * @param accountId  (required)
   * @param subreddit Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for (required)
   * @param headers Optional headers to include in the request
   * @return GetRedditFlairs200Response
   * @throws ApiException if fails to make API call
   */
  public GetRedditFlairs200Response getRedditFlairs(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull String subreddit, Map<String, String> headers) throws ApiException {
    ApiResponse<GetRedditFlairs200Response> localVarResponse = getRedditFlairsWithHttpInfo(accountId, subreddit, headers);
    return localVarResponse.getData();
  }

  /**
   * List subreddit flairs
   * Returns available post flairs for a subreddit. Some subreddits require a flair when posting.
   * @param accountId  (required)
   * @param subreddit Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for (required)
   * @return ApiResponse&lt;GetRedditFlairs200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetRedditFlairs200Response> getRedditFlairsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull String subreddit) throws ApiException {
    return getRedditFlairsWithHttpInfo(accountId, subreddit, null);
  }

  /**
   * List subreddit flairs
   * Returns available post flairs for a subreddit. Some subreddits require a flair when posting.
   * @param accountId  (required)
   * @param subreddit Subreddit name (without \&quot;r/\&quot; prefix) to fetch flairs for (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetRedditFlairs200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetRedditFlairs200Response> getRedditFlairsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull String subreddit, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getRedditFlairsRequestBuilder(accountId, subreddit, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getRedditFlairs", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetRedditFlairs200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetRedditFlairs200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetRedditFlairs200Response>() {});
        

        return new ApiResponse<GetRedditFlairs200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getRedditFlairsRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull String subreddit, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getRedditFlairs");
    }
    // verify the required parameter 'subreddit' is set
    if (subreddit == null) {
      throw new ApiException(400, "Missing the required parameter 'subreddit' when calling getRedditFlairs");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/reddit-flairs"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "subreddit";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("subreddit", subreddit));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Reddit subreddits
   * Returns the subreddits the connected Reddit account can post to. Use this to get a subreddit name when creating a Reddit post.
   * @param accountId  (required)
   * @return GetRedditSubreddits200Response
   * @throws ApiException if fails to make API call
   */
  public GetRedditSubreddits200Response getRedditSubreddits(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getRedditSubreddits(accountId, null);
  }

  /**
   * List Reddit subreddits
   * Returns the subreddits the connected Reddit account can post to. Use this to get a subreddit name when creating a Reddit post.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetRedditSubreddits200Response
   * @throws ApiException if fails to make API call
   */
  public GetRedditSubreddits200Response getRedditSubreddits(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetRedditSubreddits200Response> localVarResponse = getRedditSubredditsWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * List Reddit subreddits
   * Returns the subreddits the connected Reddit account can post to. Use this to get a subreddit name when creating a Reddit post.
   * @param accountId  (required)
   * @return ApiResponse&lt;GetRedditSubreddits200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetRedditSubreddits200Response> getRedditSubredditsWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getRedditSubredditsWithHttpInfo(accountId, null);
  }

  /**
   * List Reddit subreddits
   * Returns the subreddits the connected Reddit account can post to. Use this to get a subreddit name when creating a Reddit post.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetRedditSubreddits200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetRedditSubreddits200Response> getRedditSubredditsWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getRedditSubredditsRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getRedditSubreddits", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetRedditSubreddits200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetRedditSubreddits200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetRedditSubreddits200Response>() {});
        

        return new ApiResponse<GetRedditSubreddits200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getRedditSubredditsRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getRedditSubreddits");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/reddit-subreddits"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Generate Telegram code
   * Generate an access code (valid 15 minutes) for connecting a Telegram channel or group. Add the bot as admin, then send the code + @yourchannel to the bot. Poll PATCH /v1/connect/telegram to check status.
   * @param profileId The profile ID to connect the Telegram account to (required)
   * @return GetTelegramConnectStatus200Response
   * @throws ApiException if fails to make API call
   */
  public GetTelegramConnectStatus200Response getTelegramConnectStatus(@javax.annotation.Nonnull String profileId) throws ApiException {
    return getTelegramConnectStatus(profileId, null);
  }

  /**
   * Generate Telegram code
   * Generate an access code (valid 15 minutes) for connecting a Telegram channel or group. Add the bot as admin, then send the code + @yourchannel to the bot. Poll PATCH /v1/connect/telegram to check status.
   * @param profileId The profile ID to connect the Telegram account to (required)
   * @param headers Optional headers to include in the request
   * @return GetTelegramConnectStatus200Response
   * @throws ApiException if fails to make API call
   */
  public GetTelegramConnectStatus200Response getTelegramConnectStatus(@javax.annotation.Nonnull String profileId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetTelegramConnectStatus200Response> localVarResponse = getTelegramConnectStatusWithHttpInfo(profileId, headers);
    return localVarResponse.getData();
  }

  /**
   * Generate Telegram code
   * Generate an access code (valid 15 minutes) for connecting a Telegram channel or group. Add the bot as admin, then send the code + @yourchannel to the bot. Poll PATCH /v1/connect/telegram to check status.
   * @param profileId The profile ID to connect the Telegram account to (required)
   * @return ApiResponse&lt;GetTelegramConnectStatus200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetTelegramConnectStatus200Response> getTelegramConnectStatusWithHttpInfo(@javax.annotation.Nonnull String profileId) throws ApiException {
    return getTelegramConnectStatusWithHttpInfo(profileId, null);
  }

  /**
   * Generate Telegram code
   * Generate an access code (valid 15 minutes) for connecting a Telegram channel or group. Add the bot as admin, then send the code + @yourchannel to the bot. Poll PATCH /v1/connect/telegram to check status.
   * @param profileId The profile ID to connect the Telegram account to (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetTelegramConnectStatus200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetTelegramConnectStatus200Response> getTelegramConnectStatusWithHttpInfo(@javax.annotation.Nonnull String profileId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getTelegramConnectStatusRequestBuilder(profileId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getTelegramConnectStatus", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetTelegramConnectStatus200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetTelegramConnectStatus200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetTelegramConnectStatus200Response>() {});
        

        return new ApiResponse<GetTelegramConnectStatus200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getTelegramConnectStatusRequestBuilder(@javax.annotation.Nonnull String profileId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling getTelegramConnectStatus");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/telegram";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Complete OAuth callback
   * Exchange the OAuth authorization code for tokens and connect the account to the specified profile.
   * @param platform  (required)
   * @param handleOAuthCallbackRequest  (required)
   * @throws ApiException if fails to make API call
   */
  public void handleOAuthCallback(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest) throws ApiException {
    handleOAuthCallback(platform, handleOAuthCallbackRequest, null);
  }

  /**
   * Complete OAuth callback
   * Exchange the OAuth authorization code for tokens and connect the account to the specified profile.
   * @param platform  (required)
   * @param handleOAuthCallbackRequest  (required)
   * @param headers Optional headers to include in the request
   * @throws ApiException if fails to make API call
   */
  public void handleOAuthCallback(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest, Map<String, String> headers) throws ApiException {
    handleOAuthCallbackWithHttpInfo(platform, handleOAuthCallbackRequest, headers);
  }

  /**
   * Complete OAuth callback
   * Exchange the OAuth authorization code for tokens and connect the account to the specified profile.
   * @param platform  (required)
   * @param handleOAuthCallbackRequest  (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> handleOAuthCallbackWithHttpInfo(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest) throws ApiException {
    return handleOAuthCallbackWithHttpInfo(platform, handleOAuthCallbackRequest, null);
  }

  /**
   * Complete OAuth callback
   * Exchange the OAuth authorization code for tokens and connect the account to the specified profile.
   * @param platform  (required)
   * @param handleOAuthCallbackRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> handleOAuthCallbackWithHttpInfo(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = handleOAuthCallbackRequestBuilder(platform, handleOAuthCallbackRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("handleOAuthCallback", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody != null) {
          localVarResponseBody.readAllBytes();
        }
        return new ApiResponse<>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            null
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder handleOAuthCallbackRequestBuilder(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'platform' is set
    if (platform == null) {
      throw new ApiException(400, "Missing the required parameter 'platform' when calling handleOAuthCallback");
    }
    // verify the required parameter 'handleOAuthCallbackRequest' is set
    if (handleOAuthCallbackRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'handleOAuthCallbackRequest' when calling handleOAuthCallback");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/{platform}"
        .replace("{platform}", ApiClient.urlEncode(platform.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(handleOAuthCallbackRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Connect Telegram directly
   * Connect a Telegram channel/group directly using the chat ID. Alternative to the access code flow. The bot must already be an admin in the channel/group.
   * @param initiateTelegramConnectRequest  (required)
   * @return InitiateTelegramConnect200Response
   * @throws ApiException if fails to make API call
   */
  public InitiateTelegramConnect200Response initiateTelegramConnect(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest) throws ApiException {
    return initiateTelegramConnect(initiateTelegramConnectRequest, null);
  }

  /**
   * Connect Telegram directly
   * Connect a Telegram channel/group directly using the chat ID. Alternative to the access code flow. The bot must already be an admin in the channel/group.
   * @param initiateTelegramConnectRequest  (required)
   * @param headers Optional headers to include in the request
   * @return InitiateTelegramConnect200Response
   * @throws ApiException if fails to make API call
   */
  public InitiateTelegramConnect200Response initiateTelegramConnect(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<InitiateTelegramConnect200Response> localVarResponse = initiateTelegramConnectWithHttpInfo(initiateTelegramConnectRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Connect Telegram directly
   * Connect a Telegram channel/group directly using the chat ID. Alternative to the access code flow. The bot must already be an admin in the channel/group.
   * @param initiateTelegramConnectRequest  (required)
   * @return ApiResponse&lt;InitiateTelegramConnect200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<InitiateTelegramConnect200Response> initiateTelegramConnectWithHttpInfo(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest) throws ApiException {
    return initiateTelegramConnectWithHttpInfo(initiateTelegramConnectRequest, null);
  }

  /**
   * Connect Telegram directly
   * Connect a Telegram channel/group directly using the chat ID. Alternative to the access code flow. The bot must already be an admin in the channel/group.
   * @param initiateTelegramConnectRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;InitiateTelegramConnect200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<InitiateTelegramConnect200Response> initiateTelegramConnectWithHttpInfo(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = initiateTelegramConnectRequestBuilder(initiateTelegramConnectRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("initiateTelegramConnect", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<InitiateTelegramConnect200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        InitiateTelegramConnect200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<InitiateTelegramConnect200Response>() {});
        

        return new ApiResponse<InitiateTelegramConnect200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder initiateTelegramConnectRequestBuilder(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'initiateTelegramConnectRequest' is set
    if (initiateTelegramConnectRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'initiateTelegramConnectRequest' when calling initiateTelegramConnect");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/telegram";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(initiateTelegramConnectRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Facebook pages
   * Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Facebook access token from the OAuth callback redirect (required)
   * @return ListFacebookPages200Response
   * @throws ApiException if fails to make API call
   */
  public ListFacebookPages200Response listFacebookPages(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listFacebookPages(profileId, tempToken, null);
  }

  /**
   * List Facebook pages
   * Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Facebook access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ListFacebookPages200Response
   * @throws ApiException if fails to make API call
   */
  public ListFacebookPages200Response listFacebookPages(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    ApiResponse<ListFacebookPages200Response> localVarResponse = listFacebookPagesWithHttpInfo(profileId, tempToken, headers);
    return localVarResponse.getData();
  }

  /**
   * List Facebook pages
   * Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Facebook access token from the OAuth callback redirect (required)
   * @return ApiResponse&lt;ListFacebookPages200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListFacebookPages200Response> listFacebookPagesWithHttpInfo(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listFacebookPagesWithHttpInfo(profileId, tempToken, null);
  }

  /**
   * List Facebook pages
   * Returns the list of Facebook Pages the user can manage after OAuth. Extract tempToken and userProfile from the OAuth redirect params and pass them here. Use the X-Connect-Token header if connecting via API key.
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Facebook access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListFacebookPages200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListFacebookPages200Response> listFacebookPagesWithHttpInfo(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listFacebookPagesRequestBuilder(profileId, tempToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listFacebookPages", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListFacebookPages200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListFacebookPages200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListFacebookPages200Response>() {});
        

        return new ApiResponse<ListFacebookPages200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listFacebookPagesRequestBuilder(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling listFacebookPages");
    }
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listFacebookPages");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/facebook/select-page";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List GBP locations
   * For headless flows. Returns the list of GBP locations the user can manage. Use X-Connect-Token if connecting via API key.
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Google access token from the OAuth callback redirect (required)
   * @return ListGoogleBusinessLocations200Response
   * @throws ApiException if fails to make API call
   */
  public ListGoogleBusinessLocations200Response listGoogleBusinessLocations(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listGoogleBusinessLocations(profileId, tempToken, null);
  }

  /**
   * List GBP locations
   * For headless flows. Returns the list of GBP locations the user can manage. Use X-Connect-Token if connecting via API key.
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Google access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ListGoogleBusinessLocations200Response
   * @throws ApiException if fails to make API call
   */
  public ListGoogleBusinessLocations200Response listGoogleBusinessLocations(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    ApiResponse<ListGoogleBusinessLocations200Response> localVarResponse = listGoogleBusinessLocationsWithHttpInfo(profileId, tempToken, headers);
    return localVarResponse.getData();
  }

  /**
   * List GBP locations
   * For headless flows. Returns the list of GBP locations the user can manage. Use X-Connect-Token if connecting via API key.
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Google access token from the OAuth callback redirect (required)
   * @return ApiResponse&lt;ListGoogleBusinessLocations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListGoogleBusinessLocations200Response> listGoogleBusinessLocationsWithHttpInfo(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listGoogleBusinessLocationsWithHttpInfo(profileId, tempToken, null);
  }

  /**
   * List GBP locations
   * For headless flows. Returns the list of GBP locations the user can manage. Use X-Connect-Token if connecting via API key.
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Google access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListGoogleBusinessLocations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListGoogleBusinessLocations200Response> listGoogleBusinessLocationsWithHttpInfo(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listGoogleBusinessLocationsRequestBuilder(profileId, tempToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listGoogleBusinessLocations", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListGoogleBusinessLocations200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListGoogleBusinessLocations200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListGoogleBusinessLocations200Response>() {});
        

        return new ApiResponse<ListGoogleBusinessLocations200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listGoogleBusinessLocationsRequestBuilder(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling listGoogleBusinessLocations");
    }
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listGoogleBusinessLocations");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/googlebusiness/locations";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List LinkedIn orgs
   * Fetch full LinkedIn organization details (logos, vanity names, websites) for custom UI. No authentication required, just the tempToken from OAuth.
   * @param tempToken The temporary LinkedIn access token from the OAuth redirect (required)
   * @param orgIds Comma-separated list of organization IDs to fetch details for (max 100) (required)
   * @return ListLinkedInOrganizations200Response
   * @throws ApiException if fails to make API call
   */
  public ListLinkedInOrganizations200Response listLinkedInOrganizations(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds) throws ApiException {
    return listLinkedInOrganizations(tempToken, orgIds, null);
  }

  /**
   * List LinkedIn orgs
   * Fetch full LinkedIn organization details (logos, vanity names, websites) for custom UI. No authentication required, just the tempToken from OAuth.
   * @param tempToken The temporary LinkedIn access token from the OAuth redirect (required)
   * @param orgIds Comma-separated list of organization IDs to fetch details for (max 100) (required)
   * @param headers Optional headers to include in the request
   * @return ListLinkedInOrganizations200Response
   * @throws ApiException if fails to make API call
   */
  public ListLinkedInOrganizations200Response listLinkedInOrganizations(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds, Map<String, String> headers) throws ApiException {
    ApiResponse<ListLinkedInOrganizations200Response> localVarResponse = listLinkedInOrganizationsWithHttpInfo(tempToken, orgIds, headers);
    return localVarResponse.getData();
  }

  /**
   * List LinkedIn orgs
   * Fetch full LinkedIn organization details (logos, vanity names, websites) for custom UI. No authentication required, just the tempToken from OAuth.
   * @param tempToken The temporary LinkedIn access token from the OAuth redirect (required)
   * @param orgIds Comma-separated list of organization IDs to fetch details for (max 100) (required)
   * @return ApiResponse&lt;ListLinkedInOrganizations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListLinkedInOrganizations200Response> listLinkedInOrganizationsWithHttpInfo(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds) throws ApiException {
    return listLinkedInOrganizationsWithHttpInfo(tempToken, orgIds, null);
  }

  /**
   * List LinkedIn orgs
   * Fetch full LinkedIn organization details (logos, vanity names, websites) for custom UI. No authentication required, just the tempToken from OAuth.
   * @param tempToken The temporary LinkedIn access token from the OAuth redirect (required)
   * @param orgIds Comma-separated list of organization IDs to fetch details for (max 100) (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListLinkedInOrganizations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListLinkedInOrganizations200Response> listLinkedInOrganizationsWithHttpInfo(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listLinkedInOrganizationsRequestBuilder(tempToken, orgIds, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listLinkedInOrganizations", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListLinkedInOrganizations200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListLinkedInOrganizations200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListLinkedInOrganizations200Response>() {});
        

        return new ApiResponse<ListLinkedInOrganizations200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listLinkedInOrganizationsRequestBuilder(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listLinkedInOrganizations");
    }
    // verify the required parameter 'orgIds' is set
    if (orgIds == null) {
      throw new ApiException(400, "Missing the required parameter 'orgIds' when calling listLinkedInOrganizations");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/linkedin/organizations";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));
    localVarQueryParameterBaseName = "orgIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("orgIds", orgIds));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Pinterest boards
   * For headless flows. Returns Pinterest boards the user can post to. Use X-Connect-Token from the redirect URL.
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Pinterest access token from the OAuth callback redirect (required)
   * @return ListPinterestBoardsForSelection200Response
   * @throws ApiException if fails to make API call
   */
  public ListPinterestBoardsForSelection200Response listPinterestBoardsForSelection(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listPinterestBoardsForSelection(xConnectToken, profileId, tempToken, null);
  }

  /**
   * List Pinterest boards
   * For headless flows. Returns Pinterest boards the user can post to. Use X-Connect-Token from the redirect URL.
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Pinterest access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ListPinterestBoardsForSelection200Response
   * @throws ApiException if fails to make API call
   */
  public ListPinterestBoardsForSelection200Response listPinterestBoardsForSelection(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    ApiResponse<ListPinterestBoardsForSelection200Response> localVarResponse = listPinterestBoardsForSelectionWithHttpInfo(xConnectToken, profileId, tempToken, headers);
    return localVarResponse.getData();
  }

  /**
   * List Pinterest boards
   * For headless flows. Returns Pinterest boards the user can post to. Use X-Connect-Token from the redirect URL.
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Pinterest access token from the OAuth callback redirect (required)
   * @return ApiResponse&lt;ListPinterestBoardsForSelection200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListPinterestBoardsForSelection200Response> listPinterestBoardsForSelectionWithHttpInfo(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listPinterestBoardsForSelectionWithHttpInfo(xConnectToken, profileId, tempToken, null);
  }

  /**
   * List Pinterest boards
   * For headless flows. Returns Pinterest boards the user can post to. Use X-Connect-Token from the redirect URL.
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Pinterest access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListPinterestBoardsForSelection200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListPinterestBoardsForSelection200Response> listPinterestBoardsForSelectionWithHttpInfo(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listPinterestBoardsForSelectionRequestBuilder(xConnectToken, profileId, tempToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listPinterestBoardsForSelection", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListPinterestBoardsForSelection200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListPinterestBoardsForSelection200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListPinterestBoardsForSelection200Response>() {});
        

        return new ApiResponse<ListPinterestBoardsForSelection200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listPinterestBoardsForSelectionRequestBuilder(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'xConnectToken' is set
    if (xConnectToken == null) {
      throw new ApiException(400, "Missing the required parameter 'xConnectToken' when calling listPinterestBoardsForSelection");
    }
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling listPinterestBoardsForSelection");
    }
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listPinterestBoardsForSelection");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/pinterest/select-board";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (xConnectToken != null) {
      localVarRequestBuilder.header("X-Connect-Token", xConnectToken.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Snapchat profiles
   * For headless flows. Returns Snapchat Public Profiles the user can post to. Use X-Connect-Token from the redirect URL.
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Snapchat access token from the OAuth callback redirect (required)
   * @return ListSnapchatProfiles200Response
   * @throws ApiException if fails to make API call
   */
  public ListSnapchatProfiles200Response listSnapchatProfiles(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listSnapchatProfiles(xConnectToken, profileId, tempToken, null);
  }

  /**
   * List Snapchat profiles
   * For headless flows. Returns Snapchat Public Profiles the user can post to. Use X-Connect-Token from the redirect URL.
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Snapchat access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ListSnapchatProfiles200Response
   * @throws ApiException if fails to make API call
   */
  public ListSnapchatProfiles200Response listSnapchatProfiles(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    ApiResponse<ListSnapchatProfiles200Response> localVarResponse = listSnapchatProfilesWithHttpInfo(xConnectToken, profileId, tempToken, headers);
    return localVarResponse.getData();
  }

  /**
   * List Snapchat profiles
   * For headless flows. Returns Snapchat Public Profiles the user can post to. Use X-Connect-Token from the redirect URL.
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Snapchat access token from the OAuth callback redirect (required)
   * @return ApiResponse&lt;ListSnapchatProfiles200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListSnapchatProfiles200Response> listSnapchatProfilesWithHttpInfo(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listSnapchatProfilesWithHttpInfo(xConnectToken, profileId, tempToken, null);
  }

  /**
   * List Snapchat profiles
   * For headless flows. Returns Snapchat Public Profiles the user can post to. Use X-Connect-Token from the redirect URL.
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Snapchat access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListSnapchatProfiles200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListSnapchatProfiles200Response> listSnapchatProfilesWithHttpInfo(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listSnapchatProfilesRequestBuilder(xConnectToken, profileId, tempToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listSnapchatProfiles", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListSnapchatProfiles200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListSnapchatProfiles200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListSnapchatProfiles200Response>() {});
        

        return new ApiResponse<ListSnapchatProfiles200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listSnapchatProfilesRequestBuilder(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'xConnectToken' is set
    if (xConnectToken == null) {
      throw new ApiException(400, "Missing the required parameter 'xConnectToken' when calling listSnapchatProfiles");
    }
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling listSnapchatProfiles");
    }
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listSnapchatProfiles");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/snapchat/select-profile";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (xConnectToken != null) {
      localVarRequestBuilder.header("X-Connect-Token", xConnectToken.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select Facebook page
   * Complete the headless flow by saving the user&#39;s selected Facebook page. Pass the userProfile from the OAuth redirect and use X-Connect-Token if connecting via API key.
   * @param selectFacebookPageRequest  (required)
   * @return SelectFacebookPage200Response
   * @throws ApiException if fails to make API call
   */
  public SelectFacebookPage200Response selectFacebookPage(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest) throws ApiException {
    return selectFacebookPage(selectFacebookPageRequest, null);
  }

  /**
   * Select Facebook page
   * Complete the headless flow by saving the user&#39;s selected Facebook page. Pass the userProfile from the OAuth redirect and use X-Connect-Token if connecting via API key.
   * @param selectFacebookPageRequest  (required)
   * @param headers Optional headers to include in the request
   * @return SelectFacebookPage200Response
   * @throws ApiException if fails to make API call
   */
  public SelectFacebookPage200Response selectFacebookPage(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectFacebookPage200Response> localVarResponse = selectFacebookPageWithHttpInfo(selectFacebookPageRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Select Facebook page
   * Complete the headless flow by saving the user&#39;s selected Facebook page. Pass the userProfile from the OAuth redirect and use X-Connect-Token if connecting via API key.
   * @param selectFacebookPageRequest  (required)
   * @return ApiResponse&lt;SelectFacebookPage200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectFacebookPage200Response> selectFacebookPageWithHttpInfo(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest) throws ApiException {
    return selectFacebookPageWithHttpInfo(selectFacebookPageRequest, null);
  }

  /**
   * Select Facebook page
   * Complete the headless flow by saving the user&#39;s selected Facebook page. Pass the userProfile from the OAuth redirect and use X-Connect-Token if connecting via API key.
   * @param selectFacebookPageRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectFacebookPage200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectFacebookPage200Response> selectFacebookPageWithHttpInfo(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectFacebookPageRequestBuilder(selectFacebookPageRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectFacebookPage", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectFacebookPage200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectFacebookPage200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectFacebookPage200Response>() {});
        

        return new ApiResponse<SelectFacebookPage200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectFacebookPageRequestBuilder(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectFacebookPageRequest' is set
    if (selectFacebookPageRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectFacebookPageRequest' when calling selectFacebookPage");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/facebook/select-page";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectFacebookPageRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select GBP location
   * Complete the headless flow by saving the user&#39;s selected GBP location. Include userProfile from the OAuth redirect (contains refresh token). Use X-Connect-Token if connecting via API key.
   * @param selectGoogleBusinessLocationRequest  (required)
   * @return SelectGoogleBusinessLocation200Response
   * @throws ApiException if fails to make API call
   */
  public SelectGoogleBusinessLocation200Response selectGoogleBusinessLocation(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest) throws ApiException {
    return selectGoogleBusinessLocation(selectGoogleBusinessLocationRequest, null);
  }

  /**
   * Select GBP location
   * Complete the headless flow by saving the user&#39;s selected GBP location. Include userProfile from the OAuth redirect (contains refresh token). Use X-Connect-Token if connecting via API key.
   * @param selectGoogleBusinessLocationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return SelectGoogleBusinessLocation200Response
   * @throws ApiException if fails to make API call
   */
  public SelectGoogleBusinessLocation200Response selectGoogleBusinessLocation(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectGoogleBusinessLocation200Response> localVarResponse = selectGoogleBusinessLocationWithHttpInfo(selectGoogleBusinessLocationRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Select GBP location
   * Complete the headless flow by saving the user&#39;s selected GBP location. Include userProfile from the OAuth redirect (contains refresh token). Use X-Connect-Token if connecting via API key.
   * @param selectGoogleBusinessLocationRequest  (required)
   * @return ApiResponse&lt;SelectGoogleBusinessLocation200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectGoogleBusinessLocation200Response> selectGoogleBusinessLocationWithHttpInfo(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest) throws ApiException {
    return selectGoogleBusinessLocationWithHttpInfo(selectGoogleBusinessLocationRequest, null);
  }

  /**
   * Select GBP location
   * Complete the headless flow by saving the user&#39;s selected GBP location. Include userProfile from the OAuth redirect (contains refresh token). Use X-Connect-Token if connecting via API key.
   * @param selectGoogleBusinessLocationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectGoogleBusinessLocation200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectGoogleBusinessLocation200Response> selectGoogleBusinessLocationWithHttpInfo(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectGoogleBusinessLocationRequestBuilder(selectGoogleBusinessLocationRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectGoogleBusinessLocation", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectGoogleBusinessLocation200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectGoogleBusinessLocation200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectGoogleBusinessLocation200Response>() {});
        

        return new ApiResponse<SelectGoogleBusinessLocation200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectGoogleBusinessLocationRequestBuilder(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectGoogleBusinessLocationRequest' is set
    if (selectGoogleBusinessLocationRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectGoogleBusinessLocationRequest' when calling selectGoogleBusinessLocation");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/googlebusiness/select-location";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectGoogleBusinessLocationRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select LinkedIn org
   * Complete the LinkedIn connection flow. Set accountType to \&quot;personal\&quot; or \&quot;organization\&quot; to connect as a company page. Use X-Connect-Token if connecting via API key.
   * @param selectLinkedInOrganizationRequest  (required)
   * @return SelectLinkedInOrganization200Response
   * @throws ApiException if fails to make API call
   */
  public SelectLinkedInOrganization200Response selectLinkedInOrganization(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest) throws ApiException {
    return selectLinkedInOrganization(selectLinkedInOrganizationRequest, null);
  }

  /**
   * Select LinkedIn org
   * Complete the LinkedIn connection flow. Set accountType to \&quot;personal\&quot; or \&quot;organization\&quot; to connect as a company page. Use X-Connect-Token if connecting via API key.
   * @param selectLinkedInOrganizationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return SelectLinkedInOrganization200Response
   * @throws ApiException if fails to make API call
   */
  public SelectLinkedInOrganization200Response selectLinkedInOrganization(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectLinkedInOrganization200Response> localVarResponse = selectLinkedInOrganizationWithHttpInfo(selectLinkedInOrganizationRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Select LinkedIn org
   * Complete the LinkedIn connection flow. Set accountType to \&quot;personal\&quot; or \&quot;organization\&quot; to connect as a company page. Use X-Connect-Token if connecting via API key.
   * @param selectLinkedInOrganizationRequest  (required)
   * @return ApiResponse&lt;SelectLinkedInOrganization200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectLinkedInOrganization200Response> selectLinkedInOrganizationWithHttpInfo(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest) throws ApiException {
    return selectLinkedInOrganizationWithHttpInfo(selectLinkedInOrganizationRequest, null);
  }

  /**
   * Select LinkedIn org
   * Complete the LinkedIn connection flow. Set accountType to \&quot;personal\&quot; or \&quot;organization\&quot; to connect as a company page. Use X-Connect-Token if connecting via API key.
   * @param selectLinkedInOrganizationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectLinkedInOrganization200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectLinkedInOrganization200Response> selectLinkedInOrganizationWithHttpInfo(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectLinkedInOrganizationRequestBuilder(selectLinkedInOrganizationRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectLinkedInOrganization", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectLinkedInOrganization200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectLinkedInOrganization200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectLinkedInOrganization200Response>() {});
        

        return new ApiResponse<SelectLinkedInOrganization200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectLinkedInOrganizationRequestBuilder(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectLinkedInOrganizationRequest' is set
    if (selectLinkedInOrganizationRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectLinkedInOrganizationRequest' when calling selectLinkedInOrganization");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/linkedin/select-organization";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectLinkedInOrganizationRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select Pinterest board
   * Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
   * @param selectPinterestBoardRequest  (required)
   * @return SelectPinterestBoard200Response
   * @throws ApiException if fails to make API call
   */
  public SelectPinterestBoard200Response selectPinterestBoard(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest) throws ApiException {
    return selectPinterestBoard(selectPinterestBoardRequest, null);
  }

  /**
   * Select Pinterest board
   * Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
   * @param selectPinterestBoardRequest  (required)
   * @param headers Optional headers to include in the request
   * @return SelectPinterestBoard200Response
   * @throws ApiException if fails to make API call
   */
  public SelectPinterestBoard200Response selectPinterestBoard(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectPinterestBoard200Response> localVarResponse = selectPinterestBoardWithHttpInfo(selectPinterestBoardRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Select Pinterest board
   * Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
   * @param selectPinterestBoardRequest  (required)
   * @return ApiResponse&lt;SelectPinterestBoard200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectPinterestBoard200Response> selectPinterestBoardWithHttpInfo(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest) throws ApiException {
    return selectPinterestBoardWithHttpInfo(selectPinterestBoardRequest, null);
  }

  /**
   * Select Pinterest board
   * Complete the Pinterest connection flow. After OAuth, use this endpoint to save the selected board and complete the account connection. Use the X-Connect-Token header if you initiated the connection via API key. 
   * @param selectPinterestBoardRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectPinterestBoard200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectPinterestBoard200Response> selectPinterestBoardWithHttpInfo(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectPinterestBoardRequestBuilder(selectPinterestBoardRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectPinterestBoard", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectPinterestBoard200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectPinterestBoard200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectPinterestBoard200Response>() {});
        

        return new ApiResponse<SelectPinterestBoard200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectPinterestBoardRequestBuilder(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectPinterestBoardRequest' is set
    if (selectPinterestBoardRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectPinterestBoardRequest' when calling selectPinterestBoard");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/pinterest/select-board";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectPinterestBoardRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select Snapchat profile
   * Complete the Snapchat connection flow by saving the selected Public Profile. Snapchat requires a Public Profile to publish content. Use X-Connect-Token if connecting via API key.
   * @param selectSnapchatProfileRequest  (required)
   * @param xConnectToken Short-lived connect token from the OAuth redirect (for API users) (optional)
   * @return SelectSnapchatProfile200Response
   * @throws ApiException if fails to make API call
   */
  public SelectSnapchatProfile200Response selectSnapchatProfile(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken) throws ApiException {
    return selectSnapchatProfile(selectSnapchatProfileRequest, xConnectToken, null);
  }

  /**
   * Select Snapchat profile
   * Complete the Snapchat connection flow by saving the selected Public Profile. Snapchat requires a Public Profile to publish content. Use X-Connect-Token if connecting via API key.
   * @param selectSnapchatProfileRequest  (required)
   * @param xConnectToken Short-lived connect token from the OAuth redirect (for API users) (optional)
   * @param headers Optional headers to include in the request
   * @return SelectSnapchatProfile200Response
   * @throws ApiException if fails to make API call
   */
  public SelectSnapchatProfile200Response selectSnapchatProfile(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectSnapchatProfile200Response> localVarResponse = selectSnapchatProfileWithHttpInfo(selectSnapchatProfileRequest, xConnectToken, headers);
    return localVarResponse.getData();
  }

  /**
   * Select Snapchat profile
   * Complete the Snapchat connection flow by saving the selected Public Profile. Snapchat requires a Public Profile to publish content. Use X-Connect-Token if connecting via API key.
   * @param selectSnapchatProfileRequest  (required)
   * @param xConnectToken Short-lived connect token from the OAuth redirect (for API users) (optional)
   * @return ApiResponse&lt;SelectSnapchatProfile200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectSnapchatProfile200Response> selectSnapchatProfileWithHttpInfo(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken) throws ApiException {
    return selectSnapchatProfileWithHttpInfo(selectSnapchatProfileRequest, xConnectToken, null);
  }

  /**
   * Select Snapchat profile
   * Complete the Snapchat connection flow by saving the selected Public Profile. Snapchat requires a Public Profile to publish content. Use X-Connect-Token if connecting via API key.
   * @param selectSnapchatProfileRequest  (required)
   * @param xConnectToken Short-lived connect token from the OAuth redirect (for API users) (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectSnapchatProfile200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectSnapchatProfile200Response> selectSnapchatProfileWithHttpInfo(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectSnapchatProfileRequestBuilder(selectSnapchatProfileRequest, xConnectToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectSnapchatProfile", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectSnapchatProfile200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectSnapchatProfile200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectSnapchatProfile200Response>() {});
        

        return new ApiResponse<SelectSnapchatProfile200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectSnapchatProfileRequestBuilder(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectSnapchatProfileRequest' is set
    if (selectSnapchatProfileRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectSnapchatProfileRequest' when calling selectSnapchatProfile");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/snapchat/select-profile";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (xConnectToken != null) {
      localVarRequestBuilder.header("X-Connect-Token", xConnectToken.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectSnapchatProfileRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Update Facebook page
   * Switch which Facebook Page is active for a connected account.
   * @param accountId  (required)
   * @param updateFacebookPageRequest  (required)
   * @return UpdateFacebookPage200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateFacebookPage200Response updateFacebookPage(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest) throws ApiException {
    return updateFacebookPage(accountId, updateFacebookPageRequest, null);
  }

  /**
   * Update Facebook page
   * Switch which Facebook Page is active for a connected account.
   * @param accountId  (required)
   * @param updateFacebookPageRequest  (required)
   * @param headers Optional headers to include in the request
   * @return UpdateFacebookPage200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateFacebookPage200Response updateFacebookPage(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<UpdateFacebookPage200Response> localVarResponse = updateFacebookPageWithHttpInfo(accountId, updateFacebookPageRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Update Facebook page
   * Switch which Facebook Page is active for a connected account.
   * @param accountId  (required)
   * @param updateFacebookPageRequest  (required)
   * @return ApiResponse&lt;UpdateFacebookPage200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateFacebookPage200Response> updateFacebookPageWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest) throws ApiException {
    return updateFacebookPageWithHttpInfo(accountId, updateFacebookPageRequest, null);
  }

  /**
   * Update Facebook page
   * Switch which Facebook Page is active for a connected account.
   * @param accountId  (required)
   * @param updateFacebookPageRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;UpdateFacebookPage200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateFacebookPage200Response> updateFacebookPageWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateFacebookPageRequestBuilder(accountId, updateFacebookPageRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateFacebookPage", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<UpdateFacebookPage200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        UpdateFacebookPage200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<UpdateFacebookPage200Response>() {});
        

        return new ApiResponse<UpdateFacebookPage200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateFacebookPageRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updateFacebookPage");
    }
    // verify the required parameter 'updateFacebookPageRequest' is set
    if (updateFacebookPageRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updateFacebookPageRequest' when calling updateFacebookPage");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/facebook-page"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateFacebookPageRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Update GBP location
   * Switch which GBP location is active for a connected account.
   * @param accountId  (required)
   * @param updateGmbLocationRequest  (required)
   * @return UpdateGmbLocation200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateGmbLocation200Response updateGmbLocation(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest) throws ApiException {
    return updateGmbLocation(accountId, updateGmbLocationRequest, null);
  }

  /**
   * Update GBP location
   * Switch which GBP location is active for a connected account.
   * @param accountId  (required)
   * @param updateGmbLocationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return UpdateGmbLocation200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateGmbLocation200Response updateGmbLocation(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<UpdateGmbLocation200Response> localVarResponse = updateGmbLocationWithHttpInfo(accountId, updateGmbLocationRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Update GBP location
   * Switch which GBP location is active for a connected account.
   * @param accountId  (required)
   * @param updateGmbLocationRequest  (required)
   * @return ApiResponse&lt;UpdateGmbLocation200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateGmbLocation200Response> updateGmbLocationWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest) throws ApiException {
    return updateGmbLocationWithHttpInfo(accountId, updateGmbLocationRequest, null);
  }

  /**
   * Update GBP location
   * Switch which GBP location is active for a connected account.
   * @param accountId  (required)
   * @param updateGmbLocationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;UpdateGmbLocation200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateGmbLocation200Response> updateGmbLocationWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateGmbLocationRequestBuilder(accountId, updateGmbLocationRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateGmbLocation", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<UpdateGmbLocation200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        UpdateGmbLocation200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<UpdateGmbLocation200Response>() {});
        

        return new ApiResponse<UpdateGmbLocation200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateGmbLocationRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updateGmbLocation");
    }
    // verify the required parameter 'updateGmbLocationRequest' is set
    if (updateGmbLocationRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updateGmbLocationRequest' when calling updateGmbLocation");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/gmb-locations"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateGmbLocationRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Switch LinkedIn account type
   * Switch a LinkedIn account between personal profile and organization (company page) posting.
   * @param accountId  (required)
   * @param updateLinkedInOrganizationRequest  (required)
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response updateLinkedInOrganization(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest) throws ApiException {
    return updateLinkedInOrganization(accountId, updateLinkedInOrganizationRequest, null);
  }

  /**
   * Switch LinkedIn account type
   * Switch a LinkedIn account between personal profile and organization (company page) posting.
   * @param accountId  (required)
   * @param updateLinkedInOrganizationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response updateLinkedInOrganization(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = updateLinkedInOrganizationWithHttpInfo(accountId, updateLinkedInOrganizationRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Switch LinkedIn account type
   * Switch a LinkedIn account between personal profile and organization (company page) posting.
   * @param accountId  (required)
   * @param updateLinkedInOrganizationRequest  (required)
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> updateLinkedInOrganizationWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest) throws ApiException {
    return updateLinkedInOrganizationWithHttpInfo(accountId, updateLinkedInOrganizationRequest, null);
  }

  /**
   * Switch LinkedIn account type
   * Switch a LinkedIn account between personal profile and organization (company page) posting.
   * @param accountId  (required)
   * @param updateLinkedInOrganizationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> updateLinkedInOrganizationWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateLinkedInOrganizationRequestBuilder(accountId, updateLinkedInOrganizationRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateLinkedInOrganization", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ConnectBlueskyCredentials200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ConnectBlueskyCredentials200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ConnectBlueskyCredentials200Response>() {});
        

        return new ApiResponse<ConnectBlueskyCredentials200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateLinkedInOrganizationRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updateLinkedInOrganization");
    }
    // verify the required parameter 'updateLinkedInOrganizationRequest' is set
    if (updateLinkedInOrganizationRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updateLinkedInOrganizationRequest' when calling updateLinkedInOrganization");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/linkedin-organization"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateLinkedInOrganizationRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Set default Pinterest board
   * Sets the default board used when publishing pins for this account.
   * @param accountId  (required)
   * @param updatePinterestBoardsRequest  (required)
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response updatePinterestBoards(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest) throws ApiException {
    return updatePinterestBoards(accountId, updatePinterestBoardsRequest, null);
  }

  /**
   * Set default Pinterest board
   * Sets the default board used when publishing pins for this account.
   * @param accountId  (required)
   * @param updatePinterestBoardsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response updatePinterestBoards(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = updatePinterestBoardsWithHttpInfo(accountId, updatePinterestBoardsRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Set default Pinterest board
   * Sets the default board used when publishing pins for this account.
   * @param accountId  (required)
   * @param updatePinterestBoardsRequest  (required)
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> updatePinterestBoardsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest) throws ApiException {
    return updatePinterestBoardsWithHttpInfo(accountId, updatePinterestBoardsRequest, null);
  }

  /**
   * Set default Pinterest board
   * Sets the default board used when publishing pins for this account.
   * @param accountId  (required)
   * @param updatePinterestBoardsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> updatePinterestBoardsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updatePinterestBoardsRequestBuilder(accountId, updatePinterestBoardsRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updatePinterestBoards", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ConnectBlueskyCredentials200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ConnectBlueskyCredentials200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ConnectBlueskyCredentials200Response>() {});
        

        return new ApiResponse<ConnectBlueskyCredentials200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updatePinterestBoardsRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updatePinterestBoards");
    }
    // verify the required parameter 'updatePinterestBoardsRequest' is set
    if (updatePinterestBoardsRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updatePinterestBoardsRequest' when calling updatePinterestBoards");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/pinterest-boards"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updatePinterestBoardsRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Set default subreddit
   * Sets the default subreddit used when publishing posts for this Reddit account.
   * @param accountId  (required)
   * @param updateRedditSubredditsRequest  (required)
   * @return UpdateRedditSubreddits200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateRedditSubreddits200Response updateRedditSubreddits(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest) throws ApiException {
    return updateRedditSubreddits(accountId, updateRedditSubredditsRequest, null);
  }

  /**
   * Set default subreddit
   * Sets the default subreddit used when publishing posts for this Reddit account.
   * @param accountId  (required)
   * @param updateRedditSubredditsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return UpdateRedditSubreddits200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateRedditSubreddits200Response updateRedditSubreddits(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<UpdateRedditSubreddits200Response> localVarResponse = updateRedditSubredditsWithHttpInfo(accountId, updateRedditSubredditsRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Set default subreddit
   * Sets the default subreddit used when publishing posts for this Reddit account.
   * @param accountId  (required)
   * @param updateRedditSubredditsRequest  (required)
   * @return ApiResponse&lt;UpdateRedditSubreddits200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateRedditSubreddits200Response> updateRedditSubredditsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest) throws ApiException {
    return updateRedditSubredditsWithHttpInfo(accountId, updateRedditSubredditsRequest, null);
  }

  /**
   * Set default subreddit
   * Sets the default subreddit used when publishing posts for this Reddit account.
   * @param accountId  (required)
   * @param updateRedditSubredditsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;UpdateRedditSubreddits200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateRedditSubreddits200Response> updateRedditSubredditsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateRedditSubredditsRequestBuilder(accountId, updateRedditSubredditsRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateRedditSubreddits", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<UpdateRedditSubreddits200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        UpdateRedditSubreddits200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<UpdateRedditSubreddits200Response>() {});
        

        return new ApiResponse<UpdateRedditSubreddits200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateRedditSubredditsRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updateRedditSubreddits");
    }
    // verify the required parameter 'updateRedditSubredditsRequest' is set
    if (updateRedditSubredditsRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updateRedditSubredditsRequest' when calling updateRedditSubreddits");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/reddit-subreddits"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateRedditSubredditsRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
