/*
 * Late API
 * API reference for Late. Authenticate with a Bearer API key. Base URL: https://getlate.dev/api 
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package dev.getlate.api;

import dev.getlate.ApiClient;
import dev.getlate.ApiException;
import dev.getlate.ApiResponse;
import dev.getlate.Configuration;
import dev.getlate.Pair;

import dev.getlate.model.CompleteTelegramConnect200Response;
import dev.getlate.model.ConnectBlueskyCredentials200Response;
import dev.getlate.model.ConnectBlueskyCredentialsRequest;
import dev.getlate.model.ErrorResponse;
import dev.getlate.model.GetConnectUrl200Response;
import dev.getlate.model.GetFacebookPages200Response;
import dev.getlate.model.GetGmbLocations200Response;
import dev.getlate.model.GetLinkedInOrganizations200Response;
import dev.getlate.model.GetPendingOAuthData200Response;
import dev.getlate.model.GetPinterestBoards200Response;
import dev.getlate.model.GetRedditSubreddits200Response;
import dev.getlate.model.GetTelegramConnectStatus200Response;
import dev.getlate.model.GetYouTubeDailyViews400Response;
import dev.getlate.model.HandleOAuthCallbackRequest;
import dev.getlate.model.InitiateTelegramConnect200Response;
import dev.getlate.model.InitiateTelegramConnectRequest;
import dev.getlate.model.InlineObject;
import dev.getlate.model.ListFacebookPages200Response;
import dev.getlate.model.ListGoogleBusinessLocations200Response;
import dev.getlate.model.ListLinkedInOrganizations200Response;
import dev.getlate.model.ListPinterestBoardsForSelection200Response;
import dev.getlate.model.ListSnapchatProfiles200Response;
import dev.getlate.model.SelectFacebookPage200Response;
import dev.getlate.model.SelectFacebookPageRequest;
import dev.getlate.model.SelectGoogleBusinessLocation200Response;
import dev.getlate.model.SelectGoogleBusinessLocationRequest;
import dev.getlate.model.SelectLinkedInOrganization200Response;
import dev.getlate.model.SelectLinkedInOrganizationRequest;
import dev.getlate.model.SelectPinterestBoard200Response;
import dev.getlate.model.SelectPinterestBoardRequest;
import dev.getlate.model.SelectSnapchatProfile200Response;
import dev.getlate.model.SelectSnapchatProfileRequest;
import java.net.URI;
import dev.getlate.model.UpdateFacebookPage200Response;
import dev.getlate.model.UpdateFacebookPageRequest;
import dev.getlate.model.UpdateGmbLocation200Response;
import dev.getlate.model.UpdateGmbLocationRequest;
import dev.getlate.model.UpdateLinkedInOrganizationRequest;
import dev.getlate.model.UpdatePinterestBoardsRequest;
import dev.getlate.model.UpdateRedditSubreddits200Response;
import dev.getlate.model.UpdateRedditSubredditsRequest;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.net.http.HttpRequest;
import java.nio.channels.Channels;
import java.nio.channels.Pipe;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2026-02-04T15:39:53.952140004Z[Etc/UTC]", comments = "Generator version: 7.19.0")
public class ConnectApi {
  /**
   * Utility class for extending HttpRequest.Builder functionality.
   */
  private static class HttpRequestBuilderExtensions {
    /**
     * Adds additional headers to the provided HttpRequest.Builder. Useful for adding method/endpoint specific headers.
     *
     * @param builder the HttpRequest.Builder to which headers will be added
     * @param headers a map of header names and values to add; may be null
     * @return the same HttpRequest.Builder instance with the additional headers set
     */
    static HttpRequest.Builder withAdditionalHeaders(HttpRequest.Builder builder, Map<String, String> headers) {
        if (headers != null) {
            for (Map.Entry<String, String> entry : headers.entrySet()) {
                builder.header(entry.getKey(), entry.getValue());
            }
        }
        return builder;
    }
  }
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<InputStream>> memberVarAsyncResponseInterceptor;

  public ConnectApi() {
    this(Configuration.getDefaultApiClient());
  }

  public ConnectApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }


  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    InputStream responseBody = ApiClient.getResponseBody(response);
    String body = null;
    try {
      body = responseBody == null ? null : new String(responseBody.readAllBytes());
    } finally {
      if (responseBody != null) {
        responseBody.close();
      }
    }
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Download file from the given response.
   *
   * @param response Response
   * @return File
   * @throws ApiException If fail to read file content from response and write to disk
   */
  public File downloadFileFromResponse(HttpResponse<InputStream> response, InputStream responseBody) throws ApiException {
    if (responseBody == null) {
      throw new ApiException(new IOException("Response body is empty"));
    }
    try {
      File file = prepareDownloadFile(response);
      java.nio.file.Files.copy(responseBody, file.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);
      return file;
    } catch (IOException e) {
      throw new ApiException(e);
    }
  }

  /**
   * <p>Prepare the file for download from the response.</p>
   *
   * @param response a {@link java.net.http.HttpResponse} object.
   * @return a {@link java.io.File} object.
   * @throws java.io.IOException if any.
   */
  private File prepareDownloadFile(HttpResponse<InputStream> response) throws IOException {
    String filename = null;
    java.util.Optional<String> contentDisposition = response.headers().firstValue("Content-Disposition");
    if (contentDisposition.isPresent() && !"".equals(contentDisposition.get())) {
      // Get filename from the Content-Disposition header.
      java.util.regex.Pattern pattern = java.util.regex.Pattern.compile("filename=['\"]?([^'\"\\s]+)['\"]?");
      java.util.regex.Matcher matcher = pattern.matcher(contentDisposition.get());
      if (matcher.find())
        filename = matcher.group(1);
    }
    File file = null;
    if (filename != null) {
      java.nio.file.Path tempDir = java.nio.file.Files.createTempDirectory("swagger-gen-native");
      java.nio.file.Path filePath = java.nio.file.Files.createFile(tempDir.resolve(filename));
      file = filePath.toFile();
      tempDir.toFile().deleteOnExit();   // best effort cleanup
      file.deleteOnExit(); // best effort cleanup
    } else {
      file = java.nio.file.Files.createTempFile("download-", "").toFile();
      file.deleteOnExit(); // best effort cleanup
    }
    return file;
  }

  /**
   * Check Telegram connection status
   * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
   * @param code The access code to check status for (required)
   * @return CompleteTelegramConnect200Response
   * @throws ApiException if fails to make API call
   */
  public CompleteTelegramConnect200Response completeTelegramConnect(@javax.annotation.Nonnull String code) throws ApiException {
    return completeTelegramConnect(code, null);
  }

  /**
   * Check Telegram connection status
   * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
   * @param code The access code to check status for (required)
   * @param headers Optional headers to include in the request
   * @return CompleteTelegramConnect200Response
   * @throws ApiException if fails to make API call
   */
  public CompleteTelegramConnect200Response completeTelegramConnect(@javax.annotation.Nonnull String code, Map<String, String> headers) throws ApiException {
    ApiResponse<CompleteTelegramConnect200Response> localVarResponse = completeTelegramConnectWithHttpInfo(code, headers);
    return localVarResponse.getData();
  }

  /**
   * Check Telegram connection status
   * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
   * @param code The access code to check status for (required)
   * @return ApiResponse&lt;CompleteTelegramConnect200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CompleteTelegramConnect200Response> completeTelegramConnectWithHttpInfo(@javax.annotation.Nonnull String code) throws ApiException {
    return completeTelegramConnectWithHttpInfo(code, null);
  }

  /**
   * Check Telegram connection status
   * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.  **Recommended polling interval:** 3 seconds  **Status values:** - &#x60;pending&#x60;: Code is valid, waiting for user to complete connection - &#x60;connected&#x60;: Connection successful - channel/group is now linked - &#x60;expired&#x60;: Code has expired, generate a new one 
   * @param code The access code to check status for (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;CompleteTelegramConnect200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CompleteTelegramConnect200Response> completeTelegramConnectWithHttpInfo(@javax.annotation.Nonnull String code, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = completeTelegramConnectRequestBuilder(code, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("completeTelegramConnect", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<CompleteTelegramConnect200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        CompleteTelegramConnect200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<CompleteTelegramConnect200Response>() {});
        

        return new ApiResponse<CompleteTelegramConnect200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder completeTelegramConnectRequestBuilder(@javax.annotation.Nonnull String code, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'code' is set
    if (code == null) {
      throw new ApiException(400, "Missing the required parameter 'code' when calling completeTelegramConnect");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/telegram";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "code";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("code", code));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("PATCH", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Connect Bluesky using app password
   * Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
   * @param connectBlueskyCredentialsRequest  (required)
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response connectBlueskyCredentials(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest) throws ApiException {
    return connectBlueskyCredentials(connectBlueskyCredentialsRequest, null);
  }

  /**
   * Connect Bluesky using app password
   * Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
   * @param connectBlueskyCredentialsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response connectBlueskyCredentials(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = connectBlueskyCredentialsWithHttpInfo(connectBlueskyCredentialsRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Connect Bluesky using app password
   * Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
   * @param connectBlueskyCredentialsRequest  (required)
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> connectBlueskyCredentialsWithHttpInfo(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest) throws ApiException {
    return connectBlueskyCredentialsWithHttpInfo(connectBlueskyCredentialsRequest, null);
  }

  /**
   * Connect Bluesky using app password
   * Connect a Bluesky account using identifier (handle or email) and an app password.  To get your userId for the state parameter, call &#x60;GET /v1/users&#x60; - the response includes a &#x60;currentUserId&#x60; field. 
   * @param connectBlueskyCredentialsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> connectBlueskyCredentialsWithHttpInfo(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = connectBlueskyCredentialsRequestBuilder(connectBlueskyCredentialsRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("connectBlueskyCredentials", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ConnectBlueskyCredentials200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ConnectBlueskyCredentials200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ConnectBlueskyCredentials200Response>() {});
        

        return new ApiResponse<ConnectBlueskyCredentials200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder connectBlueskyCredentialsRequestBuilder(@javax.annotation.Nonnull ConnectBlueskyCredentialsRequest connectBlueskyCredentialsRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'connectBlueskyCredentialsRequest' is set
    if (connectBlueskyCredentialsRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'connectBlueskyCredentialsRequest' when calling connectBlueskyCredentials");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/bluesky/credentials";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(connectBlueskyCredentialsRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Start OAuth connection for a platform
   * Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
   * @param platform Social media platform to connect (required)
   * @param profileId Your Late profile ID (get from /v1/profiles) (required)
   * @param redirectUrl Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)
   * @return GetConnectUrl200Response
   * @throws ApiException if fails to make API call
   */
  public GetConnectUrl200Response getConnectUrl(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl) throws ApiException {
    return getConnectUrl(platform, profileId, redirectUrl, null);
  }

  /**
   * Start OAuth connection for a platform
   * Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
   * @param platform Social media platform to connect (required)
   * @param profileId Your Late profile ID (get from /v1/profiles) (required)
   * @param redirectUrl Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)
   * @param headers Optional headers to include in the request
   * @return GetConnectUrl200Response
   * @throws ApiException if fails to make API call
   */
  public GetConnectUrl200Response getConnectUrl(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl, Map<String, String> headers) throws ApiException {
    ApiResponse<GetConnectUrl200Response> localVarResponse = getConnectUrlWithHttpInfo(platform, profileId, redirectUrl, headers);
    return localVarResponse.getData();
  }

  /**
   * Start OAuth connection for a platform
   * Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
   * @param platform Social media platform to connect (required)
   * @param profileId Your Late profile ID (get from /v1/profiles) (required)
   * @param redirectUrl Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)
   * @return ApiResponse&lt;GetConnectUrl200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetConnectUrl200Response> getConnectUrlWithHttpInfo(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl) throws ApiException {
    return getConnectUrlWithHttpInfo(platform, profileId, redirectUrl, null);
  }

  /**
   * Start OAuth connection for a platform
   * Initiate an OAuth connection flow for any supported social media platform.  **Standard Flow (Hosted UI):** For Facebook connections, Late hosts the page selection UI:  1. Call this endpoint with your API key and &#x60;redirect_url&#x60; (optional) 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected to Late’s hosted page selector at      &#x60;/connect/facebook/select-page?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;redirect_url&#x3D;YOUR_URL&amp;connect_token&#x3D;CT&#x60; 4. After they pick a page, Late saves the connection and finally redirects to your &#x60;redirect_url&#x60; (if provided)  **Headless/Whitelabel Mode (Facebook, LinkedIn, Pinterest &amp; Google Business Profile):** Build your own fully branded selection UI while Late handles OAuth:  **Facebook:** 1. Call this endpoint with your API key and add &#x60;&amp;headless&#x3D;true&#x60;, e.g.      &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID      - &#x60;tempToken&#x60; – temporary Facebook access token      - &#x60;userProfile&#x60; – URL‑encoded JSON user profile      - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)      - &#x60;platform&#x3D;facebook&#x60;      - &#x60;step&#x3D;select_page&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/facebook/select-page&#x60; to fetch pages    - &#x60;POST /v1/connect/facebook/select-page&#x60; to save the selected page 5. In this mode, users never see Late&#39;s hosted page selector – only your UI.  **LinkedIn:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;pendingDataToken&#x60; – token to fetch OAuth data via API (see step 4)    - &#x60;connect_token&#x60; – short-lived connect token (for API auth)    - &#x60;platform&#x3D;linkedin&#x60;    - &#x60;step&#x3D;select_organization&#x60; 4. Call &#x60;GET /v1/connect/pending-data?token&#x3D;PENDING_DATA_TOKEN&#x60; to fetch the OAuth data:    - &#x60;tempToken&#x60; – temporary LinkedIn access token    - &#x60;userProfile&#x60; – JSON object with &#x60;id&#x60;, &#x60;username&#x60;, &#x60;displayName&#x60;, &#x60;profilePicture&#x60;    - &#x60;organizations&#x60; – JSON array with &#x60;id&#x60;, &#x60;urn&#x60;, &#x60;name&#x60;, &#x60;vanityName&#x60; for each org    - &#x60;refreshToken&#x60; / &#x60;expiresIn&#x60; – token metadata    This endpoint is one-time use and data expires after 10 minutes. 5. **Optional:** To fetch full organization details (logos, website, industry, description), call &#x60;GET /v1/connect/linkedin/organizations?tempToken&#x3D;X&amp;orgIds&#x3D;id1,id2,...&#x60; 6. Call &#x60;POST /v1/connect/linkedin/select-organization&#x60; with the &#x60;X-Connect-Token&#x60; header to save the selection. 7. In this mode, users never see Late&#39;s hosted organization selector – only your UI. 8. Note: If the user has no organization admin access, &#x60;step&#x3D;select_organization&#x60; will NOT be present,    and the account will be connected directly as a personal account.  **Pinterest:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Pinterest access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;pinterest&#x60;    - &#x60;step&#x3D;select_board&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/pinterest/select-board&#x60; to fetch boards    - &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selected board 5. In this mode, users never see Late&#39;s hosted board selector – only your UI.  **Google Business Profile:** 1. Call this endpoint with &#x60;&amp;headless&#x3D;true&#x60;, e.g.    &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; 2. Redirect your user to the returned &#x60;authUrl&#x60; 3. After OAuth, the user is redirected directly to **your** &#x60;redirect_url&#x60; with:    - &#x60;profileId&#x60; – your Late profile ID    - &#x60;tempToken&#x60; – temporary Google access token    - &#x60;userProfile&#x60; – URL‑encoded JSON user profile (includes refresh token info)    - &#x60;connect_token&#x60; – short‑lived connect token (for API auth)    - &#x60;platform&#x3D;googlebusiness&#x60;    - &#x60;step&#x3D;select_location&#x60; 4. Use &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and the &#x60;X-Connect-Token&#x60; header with:    - &#x60;GET /v1/connect/googlebusiness/locations&#x60; to fetch business locations    - &#x60;POST /v1/connect/googlebusiness/select-location&#x60; to save the selected location 5. In this mode, users never see Late&#39;s hosted location selector – only your UI. 
   * @param platform Social media platform to connect (required)
   * @param profileId Your Late profile ID (get from /v1/profiles) (required)
   * @param redirectUrl Optional: Your custom redirect URL after connection completes.  **Standard Mode:** Omit &#x60;headless&#x3D;true&#x60; to use our hosted page selection UI.   After the user selects a Facebook Page, Late redirects here with:   &#x60;?connected&#x3D;facebook&amp;profileId&#x3D;X&amp;username&#x3D;Y&#x60;  **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business Profile &amp; Snapchat):** Pass &#x60;headless&#x3D;true&#x60; as a query parameter on this endpoint (not inside &#x60;redirect_url&#x60;), e.g.: &#x60;GET /v1/connect/facebook?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/linkedin?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/pinterest?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/googlebusiness?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60; &#x60;GET /v1/connect/snapchat?profileId&#x3D;PROFILE_ID&amp;redirect_url&#x3D;https://yourapp.com/callback&amp;headless&#x3D;true&#x60;  After OAuth, the user is redirected directly to your &#x60;redirect_url&#x60; with OAuth data: - **Facebook:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;facebook&amp;step&#x3D;select_page&#x60; - **LinkedIn:** &#x60;?profileId&#x3D;X&amp;pendingDataToken&#x3D;TOKEN&amp;connect_token&#x3D;CT&amp;platform&#x3D;linkedin&amp;step&#x3D;select_organization&#x60;   Use &#x60;GET /v1/connect/pending-data?token&#x3D;TOKEN&#x60; to fetch tempToken, userProfile, organizations, refreshToken. - **Pinterest:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;pinterest&amp;step&#x3D;select_board&#x60; - **Google Business:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;connect_token&#x3D;CT&amp;platform&#x3D;googlebusiness&amp;step&#x3D;select_location&#x60; - **Snapchat:** &#x60;?profileId&#x3D;X&amp;tempToken&#x3D;Y&amp;userProfile&#x3D;Z&amp;publicProfiles&#x3D;PROFILES&amp;connect_token&#x3D;CT&amp;platform&#x3D;snapchat&amp;step&#x3D;select_public_profile&#x60;   (publicProfiles contains &#x60;id&#x60;, &#x60;display_name&#x60;, &#x60;username&#x60;, &#x60;profile_image_url&#x60;, &#x60;subscriber_count&#x60;)  Then use the respective endpoints to build your custom UI: - Facebook: &#x60;/v1/connect/facebook/select-page&#x60; (GET to fetch, POST to save) - LinkedIn: &#x60;/v1/connect/linkedin/organizations&#x60; (GET to fetch logos), &#x60;/v1/connect/linkedin/select-organization&#x60; (POST to save) - Pinterest: &#x60;/v1/connect/pinterest/select-board&#x60; (GET to fetch, POST to save) - Google Business: &#x60;/v1/connect/googlebusiness/locations&#x60; (GET) and &#x60;/v1/connect/googlebusiness/select-location&#x60; (POST) - Snapchat: &#x60;/v1/connect/snapchat/select-profile&#x60; (POST to save selected public profile)  Example: &#x60;https://yourdomain.com/integrations/callback&#x60;  (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetConnectUrl200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetConnectUrl200Response> getConnectUrlWithHttpInfo(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getConnectUrlRequestBuilder(platform, profileId, redirectUrl, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getConnectUrl", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetConnectUrl200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetConnectUrl200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetConnectUrl200Response>() {});
        

        return new ApiResponse<GetConnectUrl200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getConnectUrlRequestBuilder(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull String profileId, @javax.annotation.Nullable URI redirectUrl, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'platform' is set
    if (platform == null) {
      throw new ApiException(400, "Missing the required parameter 'platform' when calling getConnectUrl");
    }
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling getConnectUrl");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/{platform}"
        .replace("{platform}", ApiClient.urlEncode(platform.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "redirect_url";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("redirect_url", redirectUrl));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List available Facebook pages for a connected account
   * Returns all Facebook pages the connected account has access to, including the currently selected page.
   * @param accountId  (required)
   * @return GetFacebookPages200Response
   * @throws ApiException if fails to make API call
   */
  public GetFacebookPages200Response getFacebookPages(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getFacebookPages(accountId, null);
  }

  /**
   * List available Facebook pages for a connected account
   * Returns all Facebook pages the connected account has access to, including the currently selected page.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetFacebookPages200Response
   * @throws ApiException if fails to make API call
   */
  public GetFacebookPages200Response getFacebookPages(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetFacebookPages200Response> localVarResponse = getFacebookPagesWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * List available Facebook pages for a connected account
   * Returns all Facebook pages the connected account has access to, including the currently selected page.
   * @param accountId  (required)
   * @return ApiResponse&lt;GetFacebookPages200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetFacebookPages200Response> getFacebookPagesWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getFacebookPagesWithHttpInfo(accountId, null);
  }

  /**
   * List available Facebook pages for a connected account
   * Returns all Facebook pages the connected account has access to, including the currently selected page.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetFacebookPages200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetFacebookPages200Response> getFacebookPagesWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getFacebookPagesRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getFacebookPages", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetFacebookPages200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetFacebookPages200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetFacebookPages200Response>() {});
        

        return new ApiResponse<GetFacebookPages200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getFacebookPagesRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getFacebookPages");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/facebook-page"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List available Google Business Profile locations for a connected account
   * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
   * @param accountId  (required)
   * @return GetGmbLocations200Response
   * @throws ApiException if fails to make API call
   */
  public GetGmbLocations200Response getGmbLocations(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getGmbLocations(accountId, null);
  }

  /**
   * List available Google Business Profile locations for a connected account
   * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetGmbLocations200Response
   * @throws ApiException if fails to make API call
   */
  public GetGmbLocations200Response getGmbLocations(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetGmbLocations200Response> localVarResponse = getGmbLocationsWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * List available Google Business Profile locations for a connected account
   * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
   * @param accountId  (required)
   * @return ApiResponse&lt;GetGmbLocations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetGmbLocations200Response> getGmbLocationsWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getGmbLocationsWithHttpInfo(accountId, null);
  }

  /**
   * List available Google Business Profile locations for a connected account
   * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetGmbLocations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetGmbLocations200Response> getGmbLocationsWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getGmbLocationsRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getGmbLocations", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetGmbLocations200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetGmbLocations200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetGmbLocations200Response>() {});
        

        return new ApiResponse<GetGmbLocations200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getGmbLocationsRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getGmbLocations");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/gmb-locations"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Get available LinkedIn organizations for a connected account
   * 
   * @param accountId  (required)
   * @return GetLinkedInOrganizations200Response
   * @throws ApiException if fails to make API call
   */
  public GetLinkedInOrganizations200Response getLinkedInOrganizations(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getLinkedInOrganizations(accountId, null);
  }

  /**
   * Get available LinkedIn organizations for a connected account
   * 
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetLinkedInOrganizations200Response
   * @throws ApiException if fails to make API call
   */
  public GetLinkedInOrganizations200Response getLinkedInOrganizations(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetLinkedInOrganizations200Response> localVarResponse = getLinkedInOrganizationsWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * Get available LinkedIn organizations for a connected account
   * 
   * @param accountId  (required)
   * @return ApiResponse&lt;GetLinkedInOrganizations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetLinkedInOrganizations200Response> getLinkedInOrganizationsWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getLinkedInOrganizationsWithHttpInfo(accountId, null);
  }

  /**
   * Get available LinkedIn organizations for a connected account
   * 
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetLinkedInOrganizations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetLinkedInOrganizations200Response> getLinkedInOrganizationsWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getLinkedInOrganizationsRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getLinkedInOrganizations", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetLinkedInOrganizations200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetLinkedInOrganizations200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetLinkedInOrganizations200Response>() {});
        

        return new ApiResponse<GetLinkedInOrganizations200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getLinkedInOrganizationsRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getLinkedInOrganizations");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/linkedin-organizations"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Fetch pending OAuth selection data (Headless Mode)
   * **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
   * @param token The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter) (required)
   * @return GetPendingOAuthData200Response
   * @throws ApiException if fails to make API call
   */
  public GetPendingOAuthData200Response getPendingOAuthData(@javax.annotation.Nonnull String token) throws ApiException {
    return getPendingOAuthData(token, null);
  }

  /**
   * Fetch pending OAuth selection data (Headless Mode)
   * **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
   * @param token The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter) (required)
   * @param headers Optional headers to include in the request
   * @return GetPendingOAuthData200Response
   * @throws ApiException if fails to make API call
   */
  public GetPendingOAuthData200Response getPendingOAuthData(@javax.annotation.Nonnull String token, Map<String, String> headers) throws ApiException {
    ApiResponse<GetPendingOAuthData200Response> localVarResponse = getPendingOAuthDataWithHttpInfo(token, headers);
    return localVarResponse.getData();
  }

  /**
   * Fetch pending OAuth selection data (Headless Mode)
   * **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
   * @param token The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter) (required)
   * @return ApiResponse&lt;GetPendingOAuthData200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetPendingOAuthData200Response> getPendingOAuthDataWithHttpInfo(@javax.annotation.Nonnull String token) throws ApiException {
    return getPendingOAuthDataWithHttpInfo(token, null);
  }

  /**
   * Fetch pending OAuth selection data (Headless Mode)
   * **Fetch Pending OAuth Data for Headless Mode**  In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.) in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors when users have many organizations/pages to select from.  After OAuth redirect, use the &#x60;pendingDataToken&#x60; from the URL to fetch the stored data.  **Important:** - This endpoint is one-time use: data is deleted after being fetched - Data expires automatically after 10 minutes if not fetched - No authentication required, just the token from the redirect URL 
   * @param token The pending data token from the OAuth redirect URL (&#x60;pendingDataToken&#x60; parameter) (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetPendingOAuthData200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetPendingOAuthData200Response> getPendingOAuthDataWithHttpInfo(@javax.annotation.Nonnull String token, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getPendingOAuthDataRequestBuilder(token, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getPendingOAuthData", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetPendingOAuthData200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetPendingOAuthData200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetPendingOAuthData200Response>() {});
        

        return new ApiResponse<GetPendingOAuthData200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getPendingOAuthDataRequestBuilder(@javax.annotation.Nonnull String token, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'token' is set
    if (token == null) {
      throw new ApiException(400, "Missing the required parameter 'token' when calling getPendingOAuthData");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/pending-data";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "token";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("token", token));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Pinterest boards for a connected account
   * 
   * @param accountId  (required)
   * @return GetPinterestBoards200Response
   * @throws ApiException if fails to make API call
   */
  public GetPinterestBoards200Response getPinterestBoards(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getPinterestBoards(accountId, null);
  }

  /**
   * List Pinterest boards for a connected account
   * 
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetPinterestBoards200Response
   * @throws ApiException if fails to make API call
   */
  public GetPinterestBoards200Response getPinterestBoards(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetPinterestBoards200Response> localVarResponse = getPinterestBoardsWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * List Pinterest boards for a connected account
   * 
   * @param accountId  (required)
   * @return ApiResponse&lt;GetPinterestBoards200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetPinterestBoards200Response> getPinterestBoardsWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getPinterestBoardsWithHttpInfo(accountId, null);
  }

  /**
   * List Pinterest boards for a connected account
   * 
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetPinterestBoards200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetPinterestBoards200Response> getPinterestBoardsWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getPinterestBoardsRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getPinterestBoards", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetPinterestBoards200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetPinterestBoards200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetPinterestBoards200Response>() {});
        

        return new ApiResponse<GetPinterestBoards200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getPinterestBoardsRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getPinterestBoards");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/pinterest-boards"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Reddit subreddits for a connected account
   * 
   * @param accountId  (required)
   * @return GetRedditSubreddits200Response
   * @throws ApiException if fails to make API call
   */
  public GetRedditSubreddits200Response getRedditSubreddits(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getRedditSubreddits(accountId, null);
  }

  /**
   * List Reddit subreddits for a connected account
   * 
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return GetRedditSubreddits200Response
   * @throws ApiException if fails to make API call
   */
  public GetRedditSubreddits200Response getRedditSubreddits(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetRedditSubreddits200Response> localVarResponse = getRedditSubredditsWithHttpInfo(accountId, headers);
    return localVarResponse.getData();
  }

  /**
   * List Reddit subreddits for a connected account
   * 
   * @param accountId  (required)
   * @return ApiResponse&lt;GetRedditSubreddits200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetRedditSubreddits200Response> getRedditSubredditsWithHttpInfo(@javax.annotation.Nonnull String accountId) throws ApiException {
    return getRedditSubredditsWithHttpInfo(accountId, null);
  }

  /**
   * List Reddit subreddits for a connected account
   * 
   * @param accountId  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetRedditSubreddits200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetRedditSubreddits200Response> getRedditSubredditsWithHttpInfo(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getRedditSubredditsRequestBuilder(accountId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getRedditSubreddits", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetRedditSubreddits200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetRedditSubreddits200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetRedditSubreddits200Response>() {});
        

        return new ApiResponse<GetRedditSubreddits200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getRedditSubredditsRequestBuilder(@javax.annotation.Nonnull String accountId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling getRedditSubreddits");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/reddit-subreddits"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Generate Telegram access code
   * Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
   * @param profileId The profile ID to connect the Telegram account to (required)
   * @return GetTelegramConnectStatus200Response
   * @throws ApiException if fails to make API call
   */
  public GetTelegramConnectStatus200Response getTelegramConnectStatus(@javax.annotation.Nonnull String profileId) throws ApiException {
    return getTelegramConnectStatus(profileId, null);
  }

  /**
   * Generate Telegram access code
   * Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
   * @param profileId The profile ID to connect the Telegram account to (required)
   * @param headers Optional headers to include in the request
   * @return GetTelegramConnectStatus200Response
   * @throws ApiException if fails to make API call
   */
  public GetTelegramConnectStatus200Response getTelegramConnectStatus(@javax.annotation.Nonnull String profileId, Map<String, String> headers) throws ApiException {
    ApiResponse<GetTelegramConnectStatus200Response> localVarResponse = getTelegramConnectStatusWithHttpInfo(profileId, headers);
    return localVarResponse.getData();
  }

  /**
   * Generate Telegram access code
   * Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
   * @param profileId The profile ID to connect the Telegram account to (required)
   * @return ApiResponse&lt;GetTelegramConnectStatus200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetTelegramConnectStatus200Response> getTelegramConnectStatusWithHttpInfo(@javax.annotation.Nonnull String profileId) throws ApiException {
    return getTelegramConnectStatusWithHttpInfo(profileId, null);
  }

  /**
   * Generate Telegram access code
   * Generate a unique access code for connecting a Telegram channel or group.  **Connection Flow:** 1. Call this endpoint to get an access code (valid for 15 minutes) 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group 3. Open a private chat with the bot 4. Send: &#x60;{CODE} @yourchannel&#x60; (e.g., &#x60;LATE-ABC123 @mychannel&#x60;) 5. Poll &#x60;PATCH /v1/connect/telegram?code&#x3D;{CODE}&#x60; to check connection status  **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code. 
   * @param profileId The profile ID to connect the Telegram account to (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;GetTelegramConnectStatus200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<GetTelegramConnectStatus200Response> getTelegramConnectStatusWithHttpInfo(@javax.annotation.Nonnull String profileId, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getTelegramConnectStatusRequestBuilder(profileId, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getTelegramConnectStatus", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<GetTelegramConnectStatus200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        GetTelegramConnectStatus200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<GetTelegramConnectStatus200Response>() {});
        

        return new ApiResponse<GetTelegramConnectStatus200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getTelegramConnectStatusRequestBuilder(@javax.annotation.Nonnull String profileId, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling getTelegramConnectStatus");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/telegram";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Complete OAuth token exchange manually (for server-side flows)
   * 
   * @param platform  (required)
   * @param handleOAuthCallbackRequest  (required)
   * @throws ApiException if fails to make API call
   */
  public void handleOAuthCallback(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest) throws ApiException {
    handleOAuthCallback(platform, handleOAuthCallbackRequest, null);
  }

  /**
   * Complete OAuth token exchange manually (for server-side flows)
   * 
   * @param platform  (required)
   * @param handleOAuthCallbackRequest  (required)
   * @param headers Optional headers to include in the request
   * @throws ApiException if fails to make API call
   */
  public void handleOAuthCallback(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest, Map<String, String> headers) throws ApiException {
    handleOAuthCallbackWithHttpInfo(platform, handleOAuthCallbackRequest, headers);
  }

  /**
   * Complete OAuth token exchange manually (for server-side flows)
   * 
   * @param platform  (required)
   * @param handleOAuthCallbackRequest  (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> handleOAuthCallbackWithHttpInfo(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest) throws ApiException {
    return handleOAuthCallbackWithHttpInfo(platform, handleOAuthCallbackRequest, null);
  }

  /**
   * Complete OAuth token exchange manually (for server-side flows)
   * 
   * @param platform  (required)
   * @param handleOAuthCallbackRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> handleOAuthCallbackWithHttpInfo(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = handleOAuthCallbackRequestBuilder(platform, handleOAuthCallbackRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("handleOAuthCallback", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody != null) {
          localVarResponseBody.readAllBytes();
        }
        return new ApiResponse<>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            null
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder handleOAuthCallbackRequestBuilder(@javax.annotation.Nonnull String platform, @javax.annotation.Nonnull HandleOAuthCallbackRequest handleOAuthCallbackRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'platform' is set
    if (platform == null) {
      throw new ApiException(400, "Missing the required parameter 'platform' when calling handleOAuthCallback");
    }
    // verify the required parameter 'handleOAuthCallbackRequest' is set
    if (handleOAuthCallbackRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'handleOAuthCallbackRequest' when calling handleOAuthCallback");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/{platform}"
        .replace("{platform}", ApiClient.urlEncode(platform.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(handleOAuthCallbackRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Direct Telegram connection (power users)
   * Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
   * @param initiateTelegramConnectRequest  (required)
   * @return InitiateTelegramConnect200Response
   * @throws ApiException if fails to make API call
   */
  public InitiateTelegramConnect200Response initiateTelegramConnect(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest) throws ApiException {
    return initiateTelegramConnect(initiateTelegramConnectRequest, null);
  }

  /**
   * Direct Telegram connection (power users)
   * Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
   * @param initiateTelegramConnectRequest  (required)
   * @param headers Optional headers to include in the request
   * @return InitiateTelegramConnect200Response
   * @throws ApiException if fails to make API call
   */
  public InitiateTelegramConnect200Response initiateTelegramConnect(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<InitiateTelegramConnect200Response> localVarResponse = initiateTelegramConnectWithHttpInfo(initiateTelegramConnectRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Direct Telegram connection (power users)
   * Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
   * @param initiateTelegramConnectRequest  (required)
   * @return ApiResponse&lt;InitiateTelegramConnect200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<InitiateTelegramConnect200Response> initiateTelegramConnectWithHttpInfo(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest) throws ApiException {
    return initiateTelegramConnectWithHttpInfo(initiateTelegramConnectRequest, null);
  }

  /**
   * Direct Telegram connection (power users)
   * Connect a Telegram channel/group directly using the chat ID.  This is an alternative to the access code flow for power users who know their Telegram chat ID. The bot must already be added as an administrator in the channel/group. 
   * @param initiateTelegramConnectRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;InitiateTelegramConnect200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<InitiateTelegramConnect200Response> initiateTelegramConnectWithHttpInfo(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = initiateTelegramConnectRequestBuilder(initiateTelegramConnectRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("initiateTelegramConnect", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<InitiateTelegramConnect200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        InitiateTelegramConnect200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<InitiateTelegramConnect200Response>() {});
        

        return new ApiResponse<InitiateTelegramConnect200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder initiateTelegramConnectRequestBuilder(@javax.annotation.Nonnull InitiateTelegramConnectRequest initiateTelegramConnectRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'initiateTelegramConnectRequest' is set
    if (initiateTelegramConnectRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'initiateTelegramConnectRequest' when calling initiateTelegramConnect");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/telegram";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(initiateTelegramConnectRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Facebook Pages after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Facebook access token from the OAuth callback redirect (required)
   * @return ListFacebookPages200Response
   * @throws ApiException if fails to make API call
   */
  public ListFacebookPages200Response listFacebookPages(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listFacebookPages(profileId, tempToken, null);
  }

  /**
   * List Facebook Pages after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Facebook access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ListFacebookPages200Response
   * @throws ApiException if fails to make API call
   */
  public ListFacebookPages200Response listFacebookPages(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    ApiResponse<ListFacebookPages200Response> localVarResponse = listFacebookPagesWithHttpInfo(profileId, tempToken, headers);
    return localVarResponse.getData();
  }

  /**
   * List Facebook Pages after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Facebook access token from the OAuth callback redirect (required)
   * @return ApiResponse&lt;ListFacebookPages200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListFacebookPages200Response> listFacebookPagesWithHttpInfo(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listFacebookPagesWithHttpInfo(profileId, tempToken, null);
  }

  /**
   * List Facebook Pages after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Facebook OAuth via &#x60;/v1/connect/facebook&#x60;, you&#39;ll be redirected to  &#x60;/connect/facebook/select-page&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Facebook Pages the user can manage. Then build your  own UI to let users select a page.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Facebook access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListFacebookPages200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListFacebookPages200Response> listFacebookPagesWithHttpInfo(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listFacebookPagesRequestBuilder(profileId, tempToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listFacebookPages", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListFacebookPages200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListFacebookPages200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListFacebookPages200Response>() {});
        

        return new ApiResponse<ListFacebookPages200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listFacebookPagesRequestBuilder(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling listFacebookPages");
    }
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listFacebookPages");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/facebook/select-page";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Google Business Locations after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Google access token from the OAuth callback redirect (required)
   * @return ListGoogleBusinessLocations200Response
   * @throws ApiException if fails to make API call
   */
  public ListGoogleBusinessLocations200Response listGoogleBusinessLocations(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listGoogleBusinessLocations(profileId, tempToken, null);
  }

  /**
   * List Google Business Locations after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Google access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ListGoogleBusinessLocations200Response
   * @throws ApiException if fails to make API call
   */
  public ListGoogleBusinessLocations200Response listGoogleBusinessLocations(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    ApiResponse<ListGoogleBusinessLocations200Response> localVarResponse = listGoogleBusinessLocationsWithHttpInfo(profileId, tempToken, headers);
    return localVarResponse.getData();
  }

  /**
   * List Google Business Locations after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Google access token from the OAuth callback redirect (required)
   * @return ApiResponse&lt;ListGoogleBusinessLocations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListGoogleBusinessLocations200Response> listGoogleBusinessLocationsWithHttpInfo(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listGoogleBusinessLocationsWithHttpInfo(profileId, tempToken, null);
  }

  /**
   * List Google Business Locations after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Google Business OAuth via &#x60;/v1/connect/googlebusiness?headless&#x3D;true&#x60;, you&#39;ll be redirected  to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  For a **headless/whitelabeled flow**, extract these params from the URL and call this  endpoint to retrieve the list of Google Business locations the user can manage. Then build your  own UI to let users select a location.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key  (rather than a browser session). 
   * @param profileId Profile ID from your connection flow (required)
   * @param tempToken Temporary Google access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListGoogleBusinessLocations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListGoogleBusinessLocations200Response> listGoogleBusinessLocationsWithHttpInfo(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listGoogleBusinessLocationsRequestBuilder(profileId, tempToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listGoogleBusinessLocations", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListGoogleBusinessLocations200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListGoogleBusinessLocations200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListGoogleBusinessLocations200Response>() {});
        

        return new ApiResponse<ListGoogleBusinessLocations200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listGoogleBusinessLocationsRequestBuilder(@javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling listGoogleBusinessLocations");
    }
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listGoogleBusinessLocations");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/googlebusiness/locations";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Fetch full LinkedIn organization details (Headless Mode)
   * **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
   * @param tempToken The temporary LinkedIn access token from the OAuth redirect (required)
   * @param orgIds Comma-separated list of organization IDs to fetch details for (max 100) (required)
   * @return ListLinkedInOrganizations200Response
   * @throws ApiException if fails to make API call
   */
  public ListLinkedInOrganizations200Response listLinkedInOrganizations(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds) throws ApiException {
    return listLinkedInOrganizations(tempToken, orgIds, null);
  }

  /**
   * Fetch full LinkedIn organization details (Headless Mode)
   * **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
   * @param tempToken The temporary LinkedIn access token from the OAuth redirect (required)
   * @param orgIds Comma-separated list of organization IDs to fetch details for (max 100) (required)
   * @param headers Optional headers to include in the request
   * @return ListLinkedInOrganizations200Response
   * @throws ApiException if fails to make API call
   */
  public ListLinkedInOrganizations200Response listLinkedInOrganizations(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds, Map<String, String> headers) throws ApiException {
    ApiResponse<ListLinkedInOrganizations200Response> localVarResponse = listLinkedInOrganizationsWithHttpInfo(tempToken, orgIds, headers);
    return localVarResponse.getData();
  }

  /**
   * Fetch full LinkedIn organization details (Headless Mode)
   * **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
   * @param tempToken The temporary LinkedIn access token from the OAuth redirect (required)
   * @param orgIds Comma-separated list of organization IDs to fetch details for (max 100) (required)
   * @return ApiResponse&lt;ListLinkedInOrganizations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListLinkedInOrganizations200Response> listLinkedInOrganizationsWithHttpInfo(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds) throws ApiException {
    return listLinkedInOrganizationsWithHttpInfo(tempToken, orgIds, null);
  }

  /**
   * Fetch full LinkedIn organization details (Headless Mode)
   * **Fetch Full Organization Details for Custom UI**  After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields (additional details are excluded to prevent URL length issues with many organizations).  Use this endpoint to fetch full organization details including logos, vanity names, websites, and more if you want to display them in your custom selection UI.  **Note:** This endpoint requires no authentication - just the &#x60;tempToken&#x60; from the OAuth redirect. Details are fetched directly from LinkedIn&#39;s API in parallel for fast response times. 
   * @param tempToken The temporary LinkedIn access token from the OAuth redirect (required)
   * @param orgIds Comma-separated list of organization IDs to fetch details for (max 100) (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListLinkedInOrganizations200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListLinkedInOrganizations200Response> listLinkedInOrganizationsWithHttpInfo(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listLinkedInOrganizationsRequestBuilder(tempToken, orgIds, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listLinkedInOrganizations", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListLinkedInOrganizations200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListLinkedInOrganizations200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListLinkedInOrganizations200Response>() {});
        

        return new ApiResponse<ListLinkedInOrganizations200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listLinkedInOrganizationsRequestBuilder(@javax.annotation.Nonnull String tempToken, @javax.annotation.Nonnull String orgIds, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listLinkedInOrganizations");
    }
    // verify the required parameter 'orgIds' is set
    if (orgIds == null) {
      throw new ApiException(400, "Missing the required parameter 'orgIds' when calling listLinkedInOrganizations");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/linkedin/organizations";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));
    localVarQueryParameterBaseName = "orgIds";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("orgIds", orgIds));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Pinterest Boards after OAuth (Headless Mode)
   * **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Pinterest access token from the OAuth callback redirect (required)
   * @return ListPinterestBoardsForSelection200Response
   * @throws ApiException if fails to make API call
   */
  public ListPinterestBoardsForSelection200Response listPinterestBoardsForSelection(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listPinterestBoardsForSelection(xConnectToken, profileId, tempToken, null);
  }

  /**
   * List Pinterest Boards after OAuth (Headless Mode)
   * **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Pinterest access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ListPinterestBoardsForSelection200Response
   * @throws ApiException if fails to make API call
   */
  public ListPinterestBoardsForSelection200Response listPinterestBoardsForSelection(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    ApiResponse<ListPinterestBoardsForSelection200Response> localVarResponse = listPinterestBoardsForSelectionWithHttpInfo(xConnectToken, profileId, tempToken, headers);
    return localVarResponse.getData();
  }

  /**
   * List Pinterest Boards after OAuth (Headless Mode)
   * **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Pinterest access token from the OAuth callback redirect (required)
   * @return ApiResponse&lt;ListPinterestBoardsForSelection200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListPinterestBoardsForSelection200Response> listPinterestBoardsForSelectionWithHttpInfo(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listPinterestBoardsForSelectionWithHttpInfo(xConnectToken, profileId, tempToken, null);
  }

  /**
   * List Pinterest Boards after OAuth (Headless Mode)
   * **Retrieve Pinterest Boards for Selection UI**  After initiating Pinterest OAuth via &#x60;/v1/connect/pinterest&#x60; with &#x60;headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60; and &#x60;userProfile&#x60;.  If you want to build your own fully-branded board selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your UI and call &#x60;POST /v1/connect/pinterest/select-board&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Pinterest access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListPinterestBoardsForSelection200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListPinterestBoardsForSelection200Response> listPinterestBoardsForSelectionWithHttpInfo(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listPinterestBoardsForSelectionRequestBuilder(xConnectToken, profileId, tempToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listPinterestBoardsForSelection", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListPinterestBoardsForSelection200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListPinterestBoardsForSelection200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListPinterestBoardsForSelection200Response>() {});
        

        return new ApiResponse<ListPinterestBoardsForSelection200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listPinterestBoardsForSelectionRequestBuilder(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'xConnectToken' is set
    if (xConnectToken == null) {
      throw new ApiException(400, "Missing the required parameter 'xConnectToken' when calling listPinterestBoardsForSelection");
    }
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling listPinterestBoardsForSelection");
    }
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listPinterestBoardsForSelection");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/pinterest/select-board";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (xConnectToken != null) {
      localVarRequestBuilder.header("X-Connect-Token", xConnectToken.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * List Snapchat Public Profiles after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Snapchat access token from the OAuth callback redirect (required)
   * @return ListSnapchatProfiles200Response
   * @throws ApiException if fails to make API call
   */
  public ListSnapchatProfiles200Response listSnapchatProfiles(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listSnapchatProfiles(xConnectToken, profileId, tempToken, null);
  }

  /**
   * List Snapchat Public Profiles after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Snapchat access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ListSnapchatProfiles200Response
   * @throws ApiException if fails to make API call
   */
  public ListSnapchatProfiles200Response listSnapchatProfiles(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    ApiResponse<ListSnapchatProfiles200Response> localVarResponse = listSnapchatProfilesWithHttpInfo(xConnectToken, profileId, tempToken, headers);
    return localVarResponse.getData();
  }

  /**
   * List Snapchat Public Profiles after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Snapchat access token from the OAuth callback redirect (required)
   * @return ApiResponse&lt;ListSnapchatProfiles200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListSnapchatProfiles200Response> listSnapchatProfilesWithHttpInfo(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken) throws ApiException {
    return listSnapchatProfilesWithHttpInfo(xConnectToken, profileId, tempToken, null);
  }

  /**
   * List Snapchat Public Profiles after OAuth (Headless Mode)
   * **Headless Mode for Custom UI**  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including &#x60;tempToken&#x60;, &#x60;userProfile&#x60;, and &#x60;publicProfiles&#x60;.  If you want to build your own fully-branded profile selector (instead of Late&#39;s hosted UI), call this endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your UI and call &#x60;POST /v1/connect/snapchat/select-profile&#x60; to save the selection.  **Authentication:** Use &#x60;X-Connect-Token&#x60; header with the &#x60;connect_token&#x60; from the redirect URL. 
   * @param xConnectToken Short-lived connect token from the OAuth redirect (required)
   * @param profileId Your Late profile ID (required)
   * @param tempToken Temporary Snapchat access token from the OAuth callback redirect (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ListSnapchatProfiles200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ListSnapchatProfiles200Response> listSnapchatProfilesWithHttpInfo(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = listSnapchatProfilesRequestBuilder(xConnectToken, profileId, tempToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("listSnapchatProfiles", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ListSnapchatProfiles200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ListSnapchatProfiles200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ListSnapchatProfiles200Response>() {});
        

        return new ApiResponse<ListSnapchatProfiles200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder listSnapchatProfilesRequestBuilder(@javax.annotation.Nonnull String xConnectToken, @javax.annotation.Nonnull String profileId, @javax.annotation.Nonnull String tempToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'xConnectToken' is set
    if (xConnectToken == null) {
      throw new ApiException(400, "Missing the required parameter 'xConnectToken' when calling listSnapchatProfiles");
    }
    // verify the required parameter 'profileId' is set
    if (profileId == null) {
      throw new ApiException(400, "Missing the required parameter 'profileId' when calling listSnapchatProfiles");
    }
    // verify the required parameter 'tempToken' is set
    if (tempToken == null) {
      throw new ApiException(400, "Missing the required parameter 'tempToken' when calling listSnapchatProfiles");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/snapchat/select-profile";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "profileId";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("profileId", profileId));
    localVarQueryParameterBaseName = "tempToken";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("tempToken", tempToken));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    if (xConnectToken != null) {
      localVarRequestBuilder.header("X-Connect-Token", xConnectToken.toString());
    }
    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select a Facebook Page to complete the connection (Headless Mode)
   * **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectFacebookPageRequest  (required)
   * @return SelectFacebookPage200Response
   * @throws ApiException if fails to make API call
   */
  public SelectFacebookPage200Response selectFacebookPage(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest) throws ApiException {
    return selectFacebookPage(selectFacebookPageRequest, null);
  }

  /**
   * Select a Facebook Page to complete the connection (Headless Mode)
   * **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectFacebookPageRequest  (required)
   * @param headers Optional headers to include in the request
   * @return SelectFacebookPage200Response
   * @throws ApiException if fails to make API call
   */
  public SelectFacebookPage200Response selectFacebookPage(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectFacebookPage200Response> localVarResponse = selectFacebookPageWithHttpInfo(selectFacebookPageRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Select a Facebook Page to complete the connection (Headless Mode)
   * **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectFacebookPageRequest  (required)
   * @return ApiResponse&lt;SelectFacebookPage200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectFacebookPage200Response> selectFacebookPageWithHttpInfo(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest) throws ApiException {
    return selectFacebookPageWithHttpInfo(selectFacebookPageRequest, null);
  }

  /**
   * Select a Facebook Page to complete the connection (Headless Mode)
   * **Complete the Headless Flow**  After displaying your custom UI with the list of pages from the GET endpoint, call this  endpoint to finalize the connection with the user&#39;s selected page.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL.  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectFacebookPageRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectFacebookPage200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectFacebookPage200Response> selectFacebookPageWithHttpInfo(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectFacebookPageRequestBuilder(selectFacebookPageRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectFacebookPage", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectFacebookPage200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectFacebookPage200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectFacebookPage200Response>() {});
        

        return new ApiResponse<SelectFacebookPage200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectFacebookPageRequestBuilder(@javax.annotation.Nonnull SelectFacebookPageRequest selectFacebookPageRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectFacebookPageRequest' is set
    if (selectFacebookPageRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectFacebookPageRequest' when calling selectFacebookPage");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/facebook/select-page";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectFacebookPageRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select a Google Business location to complete the connection (Headless Mode)
   * **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectGoogleBusinessLocationRequest  (required)
   * @return SelectGoogleBusinessLocation200Response
   * @throws ApiException if fails to make API call
   */
  public SelectGoogleBusinessLocation200Response selectGoogleBusinessLocation(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest) throws ApiException {
    return selectGoogleBusinessLocation(selectGoogleBusinessLocationRequest, null);
  }

  /**
   * Select a Google Business location to complete the connection (Headless Mode)
   * **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectGoogleBusinessLocationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return SelectGoogleBusinessLocation200Response
   * @throws ApiException if fails to make API call
   */
  public SelectGoogleBusinessLocation200Response selectGoogleBusinessLocation(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectGoogleBusinessLocation200Response> localVarResponse = selectGoogleBusinessLocationWithHttpInfo(selectGoogleBusinessLocationRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Select a Google Business location to complete the connection (Headless Mode)
   * **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectGoogleBusinessLocationRequest  (required)
   * @return ApiResponse&lt;SelectGoogleBusinessLocation200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectGoogleBusinessLocation200Response> selectGoogleBusinessLocationWithHttpInfo(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest) throws ApiException {
    return selectGoogleBusinessLocationWithHttpInfo(selectGoogleBusinessLocationRequest, null);
  }

  /**
   * Select a Google Business location to complete the connection (Headless Mode)
   * **Complete the Headless Flow**  After displaying your custom UI with the list of locations from the GET &#x60;/v1/connect/googlebusiness/locations&#x60;  endpoint, call this endpoint to finalize the connection with the user&#39;s selected location.  The &#x60;userProfile&#x60; should be the decoded JSON object from the &#x60;userProfile&#x60; query param  in the OAuth callback redirect URL. It contains important token information (including refresh token).  **Note:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectGoogleBusinessLocationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectGoogleBusinessLocation200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectGoogleBusinessLocation200Response> selectGoogleBusinessLocationWithHttpInfo(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectGoogleBusinessLocationRequestBuilder(selectGoogleBusinessLocationRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectGoogleBusinessLocation", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectGoogleBusinessLocation200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectGoogleBusinessLocation200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectGoogleBusinessLocation200Response>() {});
        

        return new ApiResponse<SelectGoogleBusinessLocation200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectGoogleBusinessLocationRequestBuilder(@javax.annotation.Nonnull SelectGoogleBusinessLocationRequest selectGoogleBusinessLocationRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectGoogleBusinessLocationRequest' is set
    if (selectGoogleBusinessLocationRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectGoogleBusinessLocationRequest' when calling selectGoogleBusinessLocation");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/googlebusiness/select-location";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectGoogleBusinessLocationRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select LinkedIn organization or personal account after OAuth
   * **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectLinkedInOrganizationRequest  (required)
   * @return SelectLinkedInOrganization200Response
   * @throws ApiException if fails to make API call
   */
  public SelectLinkedInOrganization200Response selectLinkedInOrganization(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest) throws ApiException {
    return selectLinkedInOrganization(selectLinkedInOrganizationRequest, null);
  }

  /**
   * Select LinkedIn organization or personal account after OAuth
   * **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectLinkedInOrganizationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return SelectLinkedInOrganization200Response
   * @throws ApiException if fails to make API call
   */
  public SelectLinkedInOrganization200Response selectLinkedInOrganization(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectLinkedInOrganization200Response> localVarResponse = selectLinkedInOrganizationWithHttpInfo(selectLinkedInOrganizationRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Select LinkedIn organization or personal account after OAuth
   * **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectLinkedInOrganizationRequest  (required)
   * @return ApiResponse&lt;SelectLinkedInOrganization200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectLinkedInOrganization200Response> selectLinkedInOrganizationWithHttpInfo(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest) throws ApiException {
    return selectLinkedInOrganizationWithHttpInfo(selectLinkedInOrganizationRequest, null);
  }

  /**
   * Select LinkedIn organization or personal account after OAuth
   * **Complete the LinkedIn Connection Flow**  After OAuth, the user is redirected with &#x60;organizations&#x60; in the URL params (if they have org admin access). The organizations array contains &#x60;id&#x60;, &#x60;urn&#x60;, and &#x60;name&#x60; fields. Use this data to build your UI,  then call this endpoint to save the selection.  Set &#x60;accountType&#x60; to &#x60;personal&#x60; to connect as the user&#39;s personal LinkedIn profile, or &#x60;organization&#x60; to connect as a company page (requires &#x60;selectedOrganization&#x60; object).  **Personal Profile:** To connect a personal LinkedIn account, set &#x60;accountType&#x60; to &#x60;\&quot;personal\&quot;&#x60; and **omit** the &#x60;selectedOrganization&#x60; field entirely. This is the simplest flow.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectLinkedInOrganizationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectLinkedInOrganization200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectLinkedInOrganization200Response> selectLinkedInOrganizationWithHttpInfo(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectLinkedInOrganizationRequestBuilder(selectLinkedInOrganizationRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectLinkedInOrganization", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectLinkedInOrganization200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectLinkedInOrganization200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectLinkedInOrganization200Response>() {});
        

        return new ApiResponse<SelectLinkedInOrganization200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectLinkedInOrganizationRequestBuilder(@javax.annotation.Nonnull SelectLinkedInOrganizationRequest selectLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectLinkedInOrganizationRequest' is set
    if (selectLinkedInOrganizationRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectLinkedInOrganizationRequest' when calling selectLinkedInOrganization");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/linkedin/select-organization";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectLinkedInOrganizationRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select a Pinterest Board to complete the connection (Headless Mode)
   * **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectPinterestBoardRequest  (required)
   * @return SelectPinterestBoard200Response
   * @throws ApiException if fails to make API call
   */
  public SelectPinterestBoard200Response selectPinterestBoard(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest) throws ApiException {
    return selectPinterestBoard(selectPinterestBoardRequest, null);
  }

  /**
   * Select a Pinterest Board to complete the connection (Headless Mode)
   * **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectPinterestBoardRequest  (required)
   * @param headers Optional headers to include in the request
   * @return SelectPinterestBoard200Response
   * @throws ApiException if fails to make API call
   */
  public SelectPinterestBoard200Response selectPinterestBoard(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectPinterestBoard200Response> localVarResponse = selectPinterestBoardWithHttpInfo(selectPinterestBoardRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Select a Pinterest Board to complete the connection (Headless Mode)
   * **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectPinterestBoardRequest  (required)
   * @return ApiResponse&lt;SelectPinterestBoard200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectPinterestBoard200Response> selectPinterestBoardWithHttpInfo(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest) throws ApiException {
    return selectPinterestBoardWithHttpInfo(selectPinterestBoardRequest, null);
  }

  /**
   * Select a Pinterest Board to complete the connection (Headless Mode)
   * **Complete the Pinterest Connection Flow**  After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key. 
   * @param selectPinterestBoardRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectPinterestBoard200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectPinterestBoard200Response> selectPinterestBoardWithHttpInfo(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectPinterestBoardRequestBuilder(selectPinterestBoardRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectPinterestBoard", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectPinterestBoard200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectPinterestBoard200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectPinterestBoard200Response>() {});
        

        return new ApiResponse<SelectPinterestBoard200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectPinterestBoardRequestBuilder(@javax.annotation.Nonnull SelectPinterestBoardRequest selectPinterestBoardRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectPinterestBoardRequest' is set
    if (selectPinterestBoardRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectPinterestBoardRequest' when calling selectPinterestBoard");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/pinterest/select-board";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectPinterestBoardRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Select a Snapchat Public Profile to complete the connection (Headless Mode)
   * **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
   * @param selectSnapchatProfileRequest  (required)
   * @param xConnectToken Short-lived connect token from the OAuth redirect (for API users) (optional)
   * @return SelectSnapchatProfile200Response
   * @throws ApiException if fails to make API call
   */
  public SelectSnapchatProfile200Response selectSnapchatProfile(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken) throws ApiException {
    return selectSnapchatProfile(selectSnapchatProfileRequest, xConnectToken, null);
  }

  /**
   * Select a Snapchat Public Profile to complete the connection (Headless Mode)
   * **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
   * @param selectSnapchatProfileRequest  (required)
   * @param xConnectToken Short-lived connect token from the OAuth redirect (for API users) (optional)
   * @param headers Optional headers to include in the request
   * @return SelectSnapchatProfile200Response
   * @throws ApiException if fails to make API call
   */
  public SelectSnapchatProfile200Response selectSnapchatProfile(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken, Map<String, String> headers) throws ApiException {
    ApiResponse<SelectSnapchatProfile200Response> localVarResponse = selectSnapchatProfileWithHttpInfo(selectSnapchatProfileRequest, xConnectToken, headers);
    return localVarResponse.getData();
  }

  /**
   * Select a Snapchat Public Profile to complete the connection (Headless Mode)
   * **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
   * @param selectSnapchatProfileRequest  (required)
   * @param xConnectToken Short-lived connect token from the OAuth redirect (for API users) (optional)
   * @return ApiResponse&lt;SelectSnapchatProfile200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectSnapchatProfile200Response> selectSnapchatProfileWithHttpInfo(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken) throws ApiException {
    return selectSnapchatProfileWithHttpInfo(selectSnapchatProfileRequest, xConnectToken, null);
  }

  /**
   * Select a Snapchat Public Profile to complete the connection (Headless Mode)
   * **Complete the Snapchat Connection Flow**  After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection. Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.  **Headless Mode:** Use the &#x60;X-Connect-Token&#x60; header if you initiated the connection via API key.  After initiating Snapchat OAuth via &#x60;/v1/connect/snapchat?headless&#x3D;true&#x60;, you&#39;ll be redirected to your &#x60;redirect_url&#x60; with query params including: - &#x60;tempToken&#x60; - Temporary access token - &#x60;userProfile&#x60; - URL-encoded JSON with user info - &#x60;publicProfiles&#x60; - URL-encoded JSON array of available public profiles - &#x60;connect_token&#x60; - Short-lived token for API authentication - &#x60;platform&#x3D;snapchat&#x60; - &#x60;step&#x3D;select_public_profile&#x60;  Parse &#x60;publicProfiles&#x60; to build your custom selector UI, then call this endpoint with the selected profile. 
   * @param selectSnapchatProfileRequest  (required)
   * @param xConnectToken Short-lived connect token from the OAuth redirect (for API users) (optional)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;SelectSnapchatProfile200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SelectSnapchatProfile200Response> selectSnapchatProfileWithHttpInfo(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = selectSnapchatProfileRequestBuilder(selectSnapchatProfileRequest, xConnectToken, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("selectSnapchatProfile", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<SelectSnapchatProfile200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        SelectSnapchatProfile200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<SelectSnapchatProfile200Response>() {});
        

        return new ApiResponse<SelectSnapchatProfile200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder selectSnapchatProfileRequestBuilder(@javax.annotation.Nonnull SelectSnapchatProfileRequest selectSnapchatProfileRequest, @javax.annotation.Nullable String xConnectToken, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'selectSnapchatProfileRequest' is set
    if (selectSnapchatProfileRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'selectSnapchatProfileRequest' when calling selectSnapchatProfile");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/connect/snapchat/select-profile";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    if (xConnectToken != null) {
      localVarRequestBuilder.header("X-Connect-Token", xConnectToken.toString());
    }
    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(selectSnapchatProfileRequest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Update selected Facebook page for a connected account
   * 
   * @param accountId  (required)
   * @param updateFacebookPageRequest  (required)
   * @return UpdateFacebookPage200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateFacebookPage200Response updateFacebookPage(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest) throws ApiException {
    return updateFacebookPage(accountId, updateFacebookPageRequest, null);
  }

  /**
   * Update selected Facebook page for a connected account
   * 
   * @param accountId  (required)
   * @param updateFacebookPageRequest  (required)
   * @param headers Optional headers to include in the request
   * @return UpdateFacebookPage200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateFacebookPage200Response updateFacebookPage(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<UpdateFacebookPage200Response> localVarResponse = updateFacebookPageWithHttpInfo(accountId, updateFacebookPageRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Update selected Facebook page for a connected account
   * 
   * @param accountId  (required)
   * @param updateFacebookPageRequest  (required)
   * @return ApiResponse&lt;UpdateFacebookPage200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateFacebookPage200Response> updateFacebookPageWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest) throws ApiException {
    return updateFacebookPageWithHttpInfo(accountId, updateFacebookPageRequest, null);
  }

  /**
   * Update selected Facebook page for a connected account
   * 
   * @param accountId  (required)
   * @param updateFacebookPageRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;UpdateFacebookPage200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateFacebookPage200Response> updateFacebookPageWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateFacebookPageRequestBuilder(accountId, updateFacebookPageRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateFacebookPage", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<UpdateFacebookPage200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        UpdateFacebookPage200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<UpdateFacebookPage200Response>() {});
        

        return new ApiResponse<UpdateFacebookPage200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateFacebookPageRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateFacebookPageRequest updateFacebookPageRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updateFacebookPage");
    }
    // verify the required parameter 'updateFacebookPageRequest' is set
    if (updateFacebookPageRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updateFacebookPageRequest' when calling updateFacebookPage");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/facebook-page"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateFacebookPageRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Update selected Google Business Profile location for a connected account
   * 
   * @param accountId  (required)
   * @param updateGmbLocationRequest  (required)
   * @return UpdateGmbLocation200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateGmbLocation200Response updateGmbLocation(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest) throws ApiException {
    return updateGmbLocation(accountId, updateGmbLocationRequest, null);
  }

  /**
   * Update selected Google Business Profile location for a connected account
   * 
   * @param accountId  (required)
   * @param updateGmbLocationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return UpdateGmbLocation200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateGmbLocation200Response updateGmbLocation(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<UpdateGmbLocation200Response> localVarResponse = updateGmbLocationWithHttpInfo(accountId, updateGmbLocationRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Update selected Google Business Profile location for a connected account
   * 
   * @param accountId  (required)
   * @param updateGmbLocationRequest  (required)
   * @return ApiResponse&lt;UpdateGmbLocation200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateGmbLocation200Response> updateGmbLocationWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest) throws ApiException {
    return updateGmbLocationWithHttpInfo(accountId, updateGmbLocationRequest, null);
  }

  /**
   * Update selected Google Business Profile location for a connected account
   * 
   * @param accountId  (required)
   * @param updateGmbLocationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;UpdateGmbLocation200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateGmbLocation200Response> updateGmbLocationWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateGmbLocationRequestBuilder(accountId, updateGmbLocationRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateGmbLocation", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<UpdateGmbLocation200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        UpdateGmbLocation200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<UpdateGmbLocation200Response>() {});
        

        return new ApiResponse<UpdateGmbLocation200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateGmbLocationRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateGmbLocationRequest updateGmbLocationRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updateGmbLocation");
    }
    // verify the required parameter 'updateGmbLocationRequest' is set
    if (updateGmbLocationRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updateGmbLocationRequest' when calling updateGmbLocation");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/gmb-locations"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateGmbLocationRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Switch LinkedIn account type (personal/organization)
   * 
   * @param accountId  (required)
   * @param updateLinkedInOrganizationRequest  (required)
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response updateLinkedInOrganization(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest) throws ApiException {
    return updateLinkedInOrganization(accountId, updateLinkedInOrganizationRequest, null);
  }

  /**
   * Switch LinkedIn account type (personal/organization)
   * 
   * @param accountId  (required)
   * @param updateLinkedInOrganizationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response updateLinkedInOrganization(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = updateLinkedInOrganizationWithHttpInfo(accountId, updateLinkedInOrganizationRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Switch LinkedIn account type (personal/organization)
   * 
   * @param accountId  (required)
   * @param updateLinkedInOrganizationRequest  (required)
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> updateLinkedInOrganizationWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest) throws ApiException {
    return updateLinkedInOrganizationWithHttpInfo(accountId, updateLinkedInOrganizationRequest, null);
  }

  /**
   * Switch LinkedIn account type (personal/organization)
   * 
   * @param accountId  (required)
   * @param updateLinkedInOrganizationRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> updateLinkedInOrganizationWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateLinkedInOrganizationRequestBuilder(accountId, updateLinkedInOrganizationRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateLinkedInOrganization", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ConnectBlueskyCredentials200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ConnectBlueskyCredentials200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ConnectBlueskyCredentials200Response>() {});
        

        return new ApiResponse<ConnectBlueskyCredentials200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateLinkedInOrganizationRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateLinkedInOrganizationRequest updateLinkedInOrganizationRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updateLinkedInOrganization");
    }
    // verify the required parameter 'updateLinkedInOrganizationRequest' is set
    if (updateLinkedInOrganizationRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updateLinkedInOrganizationRequest' when calling updateLinkedInOrganization");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/linkedin-organization"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateLinkedInOrganizationRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Set default Pinterest board on the connection
   * 
   * @param accountId  (required)
   * @param updatePinterestBoardsRequest  (required)
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response updatePinterestBoards(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest) throws ApiException {
    return updatePinterestBoards(accountId, updatePinterestBoardsRequest, null);
  }

  /**
   * Set default Pinterest board on the connection
   * 
   * @param accountId  (required)
   * @param updatePinterestBoardsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ConnectBlueskyCredentials200Response
   * @throws ApiException if fails to make API call
   */
  public ConnectBlueskyCredentials200Response updatePinterestBoards(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<ConnectBlueskyCredentials200Response> localVarResponse = updatePinterestBoardsWithHttpInfo(accountId, updatePinterestBoardsRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Set default Pinterest board on the connection
   * 
   * @param accountId  (required)
   * @param updatePinterestBoardsRequest  (required)
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> updatePinterestBoardsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest) throws ApiException {
    return updatePinterestBoardsWithHttpInfo(accountId, updatePinterestBoardsRequest, null);
  }

  /**
   * Set default Pinterest board on the connection
   * 
   * @param accountId  (required)
   * @param updatePinterestBoardsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;ConnectBlueskyCredentials200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ConnectBlueskyCredentials200Response> updatePinterestBoardsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updatePinterestBoardsRequestBuilder(accountId, updatePinterestBoardsRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updatePinterestBoards", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<ConnectBlueskyCredentials200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        ConnectBlueskyCredentials200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<ConnectBlueskyCredentials200Response>() {});
        

        return new ApiResponse<ConnectBlueskyCredentials200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updatePinterestBoardsRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdatePinterestBoardsRequest updatePinterestBoardsRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updatePinterestBoards");
    }
    // verify the required parameter 'updatePinterestBoardsRequest' is set
    if (updatePinterestBoardsRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updatePinterestBoardsRequest' when calling updatePinterestBoards");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/pinterest-boards"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updatePinterestBoardsRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

  /**
   * Set default subreddit on the connection
   * 
   * @param accountId  (required)
   * @param updateRedditSubredditsRequest  (required)
   * @return UpdateRedditSubreddits200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateRedditSubreddits200Response updateRedditSubreddits(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest) throws ApiException {
    return updateRedditSubreddits(accountId, updateRedditSubredditsRequest, null);
  }

  /**
   * Set default subreddit on the connection
   * 
   * @param accountId  (required)
   * @param updateRedditSubredditsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return UpdateRedditSubreddits200Response
   * @throws ApiException if fails to make API call
   */
  public UpdateRedditSubreddits200Response updateRedditSubreddits(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest, Map<String, String> headers) throws ApiException {
    ApiResponse<UpdateRedditSubreddits200Response> localVarResponse = updateRedditSubredditsWithHttpInfo(accountId, updateRedditSubredditsRequest, headers);
    return localVarResponse.getData();
  }

  /**
   * Set default subreddit on the connection
   * 
   * @param accountId  (required)
   * @param updateRedditSubredditsRequest  (required)
   * @return ApiResponse&lt;UpdateRedditSubreddits200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateRedditSubreddits200Response> updateRedditSubredditsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest) throws ApiException {
    return updateRedditSubredditsWithHttpInfo(accountId, updateRedditSubredditsRequest, null);
  }

  /**
   * Set default subreddit on the connection
   * 
   * @param accountId  (required)
   * @param updateRedditSubredditsRequest  (required)
   * @param headers Optional headers to include in the request
   * @return ApiResponse&lt;UpdateRedditSubreddits200Response&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<UpdateRedditSubreddits200Response> updateRedditSubredditsWithHttpInfo(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest, Map<String, String> headers) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateRedditSubredditsRequestBuilder(accountId, updateRedditSubredditsRequest, headers);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      InputStream localVarResponseBody = null;
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateRedditSubreddits", localVarResponse);
        }
        localVarResponseBody = ApiClient.getResponseBody(localVarResponse);
        if (localVarResponseBody == null) {
          return new ApiResponse<UpdateRedditSubreddits200Response>(
              localVarResponse.statusCode(),
              localVarResponse.headers().map(),
              null
          );
        }

        
        
        String responseBody = new String(localVarResponseBody.readAllBytes());
        UpdateRedditSubreddits200Response responseValue = responseBody.isBlank()? null: memberVarObjectMapper.readValue(responseBody, new TypeReference<UpdateRedditSubreddits200Response>() {});
        

        return new ApiResponse<UpdateRedditSubreddits200Response>(
            localVarResponse.statusCode(),
            localVarResponse.headers().map(),
            responseValue
        );
      } finally {
        if (localVarResponseBody != null) {
          localVarResponseBody.close();
        }
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateRedditSubredditsRequestBuilder(@javax.annotation.Nonnull String accountId, @javax.annotation.Nonnull UpdateRedditSubredditsRequest updateRedditSubredditsRequest, Map<String, String> headers) throws ApiException {
    // verify the required parameter 'accountId' is set
    if (accountId == null) {
      throw new ApiException(400, "Missing the required parameter 'accountId' when calling updateRedditSubreddits");
    }
    // verify the required parameter 'updateRedditSubredditsRequest' is set
    if (updateRedditSubredditsRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'updateRedditSubredditsRequest' when calling updateRedditSubreddits");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v1/accounts/{accountId}/reddit-subreddits"
        .replace("{accountId}", ApiClient.urlEncode(accountId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(updateRedditSubredditsRequest);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    // Add custom headers if provided
    localVarRequestBuilder = HttpRequestBuilderExtensions.withAdditionalHeaders(localVarRequestBuilder, headers);
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }

}
